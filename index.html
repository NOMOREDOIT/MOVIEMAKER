<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Movie Meme Maker Studio</title>
<link rel="icon" type="image/png" href="favicon.ico">
<!-- PWA Manifest Link -->
<link rel="manifest" href="manifest.json">
<!-- Preload VT323 font to prevent FOUT -->
<link rel="preload" as="font" type="font/woff2" href="https://fonts.gstatic.com/s/vt323/v16/pxiDypMTK5zD_J_V1rO-D19.woff2" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<!-- ADDED FONT AWESOME FOR FOOTER ICONS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<style>
#loading-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background-color:#faf9f5;color:#2b2b2b;display:flex;align-items:center;justify-content:center;z-index:9999;transition:opacity .5s ease-in-out}#loading-overlay h1{font-family:'VT323',monospace;font-size:2.5rem;text-shadow:2px 2px 0 #000}#loading-overlay h1::after{content:'.';display:inline-block;width:3ch;text-align:left;animation:ellipsis 1.4s infinite}:root{--bg:#f2efe8;--ink:#2b2b2b;--mid:#c2c2c2;--light:#faf9f5;--light-rgb:250,249,245;--shadow:#7a7a7a;--danger-color:#cc4444;--action-color:#4477cc;--success-color:#55cc55;--bg-rgb:242,239,232;--action-color-rgb:68,119,204}html{box-sizing:border-box}*,:after,:before{box-sizing:inherit}body{font-family:'VT323',monospace;background:var(--bg) url(./assets/wallpaper.png) repeat fixed;color:var(--ink);display:flex;flex-direction:column;align-items:center;padding:10px;margin:0;height:100vh;overflow:hidden;transition:background-color .3s,color .3s}body[data-theme-is-dark=true] .titlebar{color:var(--ink)}body[data-theme-is-dark=true] #shortcuts-dropdown li kbd{border-color:var(--mid)}body[data-theme-is-dark=true] .mg-btn:hover{filter:brightness(1.2)}body[data-theme-is-dark=true] .mg-btn.generate{background-color:var(--action-color);color:var(--ink)}body[data-theme-is-dark=true] .mg-btn.active,body[data-theme-is-dark=true] .mg-btn.record{color:var(--ink)}body[data-theme-is-dark=true] .placeholder-text{color:var(--ink)}body[data-theme-is-dark=true] #text-dropdown input[type=range]::-webkit-slider-thumb,body[data-theme-is-dark=true] #visuals-dropdown input[type=range]::-webkit-slider-thumb{background:var(--action-color)}body[data-theme-is-dark=true] #text-dropdown input[type=range]::-moz-range-thumb,body[data-theme-is-dark=true] #visuals-dropdown input[type=range]::-moz-range-thumb{background:var(--action-color)}body[data-theme-is-dark=true] #mg-asset-picker-wrapper,body[data-theme-is-dark=true] #mg-asset-picker-wrapper .overlay-close-btn{color:var(--ink)}body[data-theme-is-dark=true] #mg-countdown-overlay{color:var(--ink);text-shadow:2px 2px 0 var(--action-color),-2px -2px 0 var(--action-color),2px -2px 0 var(--action-color),-2px 2px 0 var(--action-color)}body[data-theme-is-dark=true] #mg-gravity-menu input[type=number]{border-color:var(--mid);color:var(--ink)}body[data-theme-is-dark=true] .mg-overlay-base{background:rgba(var(--bg-rgb),.5)}body[data-theme-is-dark=true] #canvas-panel.drag-over #canvas-placeholder,body[data-theme-is-dark=true] #canvas-placeholder:hover{background-color:rgba(var(--light-rgb),.5)}.window{position:relative;background:var(--light);border:2px solid var(--ink);box-shadow:4px 4px 0 var(--ink);width:100%;max-width:1600px;margin:0 auto;height:calc(100vh - 20px);display:flex;flex-direction:column;overflow:hidden;transition:background-color .3s,border-color .3s,box-shadow .3s}.titlebar{height:28px;background:var(--mid);display:flex;align-items:center;justify-content:space-between;padding:0 8px;border-bottom:2px solid var(--ink);font-size:20px;flex-shrink:0;cursor:default;position:relative;transition:background-color .3s,border-color .3s}.titlebar-controls{display:flex;align-items:center;gap:8px}.controls-fake{display:flex;gap:4px}.btn-square{width:16px;height:16px;background:var(--light);border:2px solid var(--ink)}.controls-fake .btn-square:first-child{background-color:var(--success-color)}.controls-fake .btn-square:last-child{background-color:var(--danger-color)}#audio-btn,#shortcuts-btn,#text-btn,#toggle-view-btn,#visuals-btn{font-family:inherit;font-size:1.1rem;background:var(--light);border:2px solid var(--ink);padding:0 8px;cursor:pointer;transition:background-color .3s,border-color .3s,color .3s;color:var(--ink)}#toggle-view-btn{padding:0 4px;font-size:18px}#shortcuts-dropdown{right:8px}#shortcuts-dropdown.visible{display:block}#shortcuts-dropdown h5{margin:0 0 .5rem;font-size:1.25rem;text-align:center}#shortcuts-dropdown ul{margin:0;padding:0;list-style:none;font-size:1rem}#shortcuts-dropdown li{display:flex;justify-content:space-between;padding:2px 0}#shortcuts-dropdown li kbd{font-family:inherit;border:2px solid var(--ink);padding:0 4px;background:var(--bg);transition:background-color .3s,border-color .3s,color .3s}#audio-dropdown,#shortcuts-dropdown,#text-dropdown,#visuals-dropdown{display:none;position:absolute;top:28px;background:rgba(var(--light-rgb),.65);-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px);border:2px solid var(--ink);box-shadow:4px 4px 0 var(--ink);padding:.5rem 1rem;z-index:100;width:250px;transition:background .2s,backdrop-filter .2s,box-shadow .2s,border-color .2s}#visuals-dropdown{right:320px}#text-dropdown{right:216px}#audio-dropdown{right:102px}#audio-dropdown.visible,#text-dropdown.visible,#visuals-dropdown.visible{display:block}#audio-dropdown .action-buttons,#audio-dropdown h5,#audio-dropdown p,#text-dropdown .slider-container,#text-dropdown h5,#text-dropdown h6,#visuals-dropdown .slider-container,#visuals-dropdown h5,#visuals-dropdown h6{transition:opacity .2s}#audio-dropdown h5,#text-dropdown h5,#visuals-dropdown h5{margin:0 0 .5rem;font-size:1.25rem;text-align:center}#text-dropdown h6,#visuals-dropdown h6{font-size:1.15rem;font-weight:700;text-align:left;margin-top:.5rem;margin-bottom:.5rem;border-bottom:2px solid var(--mid);padding-bottom:2px}#text-dropdown label,#visuals-dropdown label{display:block;margin-top:.5rem;font-size:1rem}#visuals-dropdown.is-scrubbing{background:transparent;-webkit-backdrop-filter:none;backdrop-filter:none;box-shadow:none;border-color:transparent}#visuals-dropdown.is-scrubbing>h5,#visuals-dropdown.is-scrubbing .slider-container,#visuals-dropdown.is-scrubbing>div>h6{opacity:0;pointer-events:none}#visuals-dropdown.is-scrubbing .slider-container.is-active-slider{opacity:1;pointer-events:auto}#text-dropdown.is-scrubbing{background:transparent;-webkit-backdrop-filter:none;backdrop-filter:none;box-shadow:none;border-color:transparent}#text-dropdown.is-scrubbing>h5,#text-dropdown.is-scrubbing .slider-container,#text-dropdown.is-scrubbing #text-layer-manager{opacity:0;pointer-events:none}#text-dropdown.is-scrubbing .slider-container.is-active-slider{opacity:1;pointer-events:auto}#text-dropdown input[type=range],#visuals-dropdown input[type=range]{width:100%;-webkit-appearance:none;appearance:none;height:2px;background:var(--ink);outline:0}#text-dropdown input[type=range]::-webkit-slider-thumb,#visuals-dropdown input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:var(--ink);border-radius:50%;cursor:pointer}body[data-theme-is-dark=true] #text-dropdown input[type=range]::-webkit-slider-thumb,body[data-theme-is-dark=true] #visuals-dropdown input[type=range]::-webkit-slider-thumb{background:var(--action-color)}#text-dropdown input[type=range]::-moz-range-thumb,#visuals-dropdown input[type=range]::-moz-range-thumb{width:16px;height:16px;background:var(--ink);border-radius:50%;cursor:pointer;border:none}body[data-theme-is-dark=true] #text-dropdown input[type=range]::-moz-range-thumb,body[data-theme-is-dark=true] #visuals-dropdown input[type=range]::-moz-range-thumb{background:var(--action-color)}#asset-visuals-controls.disabled,#audio-controls.disabled,#text-visuals-controls.disabled{opacity:.5;pointer-events:none}#audio-file-name{font-size:.9rem;text-align:center;word-break:break-all;padding:.5rem;background:var(--bg);border:2px inset var(--mid);min-height:40px;transition:background-color .3s,border-color .3s}.mg-btn{font-family:inherit;font-size:18px;background:var(--light);border:2px solid var(--ink);padding:8px 16px;margin:4px;cursor:pointer;text-decoration:none;color:var(--ink);transition:.2s all;box-shadow:2px 2px 0 var(--shadow);width:100%;white-space:nowrap}body[data-theme-is-dark=true] .mg-btn:hover{filter:brightness(1.2)}.mg-btn:hover{transform:translate(2px,2px);box-shadow:0 0 0 var(--shadow)}.mg-btn.disabled,.mg-btn:disabled{opacity:.5;pointer-events:none;box-shadow:none;transform:none}.mg-btn.active{background-color:var(--danger-color);color:var(--light);box-shadow:none;transform:translate(2px,2px)}.mg-btn.success{background-color:var(--success-color)}.mg-btn.record{background-color:var(--danger-color);color:var(--light)}.mg-btn.generate{background-color:var(--ink);color:var(--light)}body[data-theme-is-dark=true] .mg-btn.generate{background-color:var(--action-color);color:var(--ink)}body[data-theme-is-dark=true] .mg-btn.active,body[data-theme-is-dark=true] .mg-btn.record{color:var(--ink)}.hidden{display:none!important}#studio-container{display:grid;grid-template-columns:320px 1fr;grid-template-rows:minmax(0,1fr);gap:1.5rem;padding:1.5rem;flex-grow:1;min-height:0}#controls-panel{display:flex;flex-direction:column;gap:1rem;overflow-y:auto;min-height:0}#canvas-panel{display:flex;align-items:center;justify-content:center;border:2px solid var(--ink);background-color:var(--mid);position:relative;min-height:0;transition:background-color .5s ease-in-out;overflow:hidden}#controls-panel fieldset{background:var(--light);border:2px solid var(--ink);padding:.8rem;margin:0;text-align:left;transition:background-color .3s,border-color .3s,color .3s}#controls-panel legend{font-size:1.2rem;font-weight:400;padding:0 .25rem}.action-buttons{display:grid;grid-template-columns:1fr 1fr;gap:.5rem}.scene-controls-container{display:flex;flex-direction:column;gap:.5rem}.scene-controls-container>.mg-btn{margin-left:0;margin-right:0}#mg-commit-layer-btn,#scene-actions-container .mg-btn{white-space:normal;text-align:center}#recording-status{display:flex;align-items:center;justify-content:center;gap:8px;font-size:1.2rem;color:var(--danger-color)}#recording-indicator{width:12px;height:12px;background-color:var(--danger-color);border:1px solid var(--ink);border-radius:50%;animation:blink 1s infinite}@keyframes blink{50%{opacity:.3}}.placeholder-text{color:var(--shadow);font-size:1.1rem;text-align:center;padding:1rem;width:100%}body[data-theme-is-dark=true] .placeholder-text{color:var(--ink)}#mg-asset-palette{display:flex;gap:.5rem;flex-wrap:wrap;min-height:70px;align-content:flex-start}.layer-thumb,.palette-slot{width:60px;height:60px;border:2px solid var(--ink);background:var(--light);cursor:pointer;position:relative;box-shadow:2px 2px 0 var(--shadow)}.layer-thumb.locked{opacity:.6;cursor:default;box-shadow:none}.layer-thumb.locked .layer-controls{display:none}.layer-thumb.locked:hover .layer-controls{display:flex}.layer-thumb{cursor:grab}.palette-slot.empty{display:flex;align-items:center;justify-content:center;font-size:3rem;line-height:1;color:var(--mid);transition:all .2s}.palette-slot.empty:hover{background-color:#e0e0e0;color:var(--ink)}body[data-theme-is-dark=true] .palette-slot.empty{color:var(--ink)}body[data-theme-is-dark=true] .palette-slot.empty:hover{background-color:var(--mid);color:var(--ink)}.layer-thumb img,.layer-thumb video{width:100%;height:100%;-o-object-fit:cover;object-fit:cover;pointer-events:none}.layer-thumb.active{border:2px solid var(--action-color);transform:scale(1.05);box-shadow:none}.layer-controls{position:absolute;top:-5px;right:-5px;display:flex;gap:2px}.layer-btn{background-color:var(--danger-color);border:1px solid var(--ink);color:#fff;font-size:.8rem;font-weight:700;line-height:1;padding:1px 4px;cursor:pointer;width:18px;height:18px;text-align:center}#scene-tray{display:flex;gap:.5rem;flex-wrap:wrap;min-height:65px;align-content:flex-start;padding-bottom:.5rem;border-bottom:2px solid var(--mid);margin-bottom:.5rem}.scene-thumb{width:80px;height:55px;border:2px solid var(--ink);background-color:var(--mid);cursor:pointer;position:relative;box-shadow:2px 2px 0 var(--shadow);background-size:cover;background-position:center;display:flex;color:var(--light);text-shadow:1px 1px 0 var(--ink);align-items:center;justify-content:center;font-size:1.5rem;transition:all .2s}body[data-theme-is-dark=true] .scene-thumb{text-shadow:1px 1px 0 var(--shadow)}.scene-thumb.active{border-color:var(--action-color);transform:scale(1.05);box-shadow:0 0 0 var(--shadow)}.scene-delete-btn{position:absolute;top:-5px;right:-5px;background-color:var(--danger-color);border:1px solid var(--ink);color:#fff;font-size:.8rem;font-weight:700;line-height:1;padding:1px 4px;cursor:pointer;width:18px;height:18px;text-align:center;opacity:0;transition:opacity .2s}.scene-thumb:hover .scene-delete-btn{opacity:1}.scene-thumb.active:hover .scene-delete-btn{display:none}#mg-controls-overlay-canvas,#mg-movie-canvas,#mg-pasteboard-overlay-canvas{position:absolute}#mg-controls-overlay-canvas,#mg-pasteboard-overlay-canvas{pointer-events:none}#mg-movie-canvas{pointer-events:auto}.mg-overlay-base{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1000;display:flex;align-items:center;justify-content:center;opacity:0;visibility:hidden;pointer-events:none;transition:opacity .3s,visibility 0s .3s;background:rgba(10,10,10,.25)}body[data-theme-is-dark=true] .mg-overlay-base{background:rgba(var(--bg-rgb),.5)}.mg-overlay-base.visible{opacity:1;visibility:visible;pointer-events:auto;transition:opacity .3s,visibility 0s 0s}.overlay-close-btn{position:absolute;top:8px;right:10px;background:0 0;border:none;line-height:1;cursor:pointer;padding:5px;font-family:'VT323',monospace;color:var(--ink);font-size:2rem;z-index:10;transition:opacity .2s}.overlay-close-btn:hover{opacity:.6}#mg-asset-picker-wrapper.window{background:rgba(var(--light-rgb),.85);-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);border:2px solid var(--ink);box-shadow:4px 4px 0 var(--ink);padding:2rem;max-width:450px;width:90vw;text-align:center;color:var(--ink);height:auto;max-height:90vh}#mg-asset-picker-wrapper .overlay-close-btn{color:var(--ink)}body[data-theme-is-dark=true] #mg-asset-picker-wrapper,body[data-theme-is-dark=true] #mg-asset-picker-wrapper .overlay-close-btn{color:var(--ink)}#mg-asset-picker-wrapper h4{font-size:1.8rem;font-weight:400;margin:0 0 .5rem}#mg-asset-picker-wrapper>p{font-size:1rem;margin:0 0 1.5rem}#mg-asset-drop-zone{border:4px dashed var(--mid);border-radius:10px;padding:2rem;color:var(--mid);cursor:pointer;transition:all .2s ease-in-out;display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;aspect-ratio:1/1}#mg-asset-drop-zone h3{font-size:1.5rem;margin:0 0 .5rem;pointer-events:none}#mg-asset-drop-zone p{font-size:1rem;margin:0;pointer-events:none}#mg-asset-drop-zone.drag-over,#mg-asset-drop-zone:hover{border-color:var(--ink);color:var(--ink);background-color:rgba(var(--action-color-rgb),.1);border-style:solid}#mg-asset-picker-actions{display:none}#mg-toast{visibility:hidden;position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:var(--light);border:2px solid var(--ink);padding:.5rem 1rem;color:var(--ink);font-size:1rem;z-index:2000;box-shadow:4px 4px 0 var(--ink)}#mg-countdown-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:transparent;display:flex;align-items:center;justify-content:center;z-index:3000;color:var(--light);text-shadow:2px 2px 0 var(--ink),-2px -2px 0 var(--ink),2px -2px 0 var(--ink),-2px 2px 0 var(--ink);font-size:15vw;pointer-events:auto}body[data-theme-is-dark=true] #mg-countdown-overlay{color:var(--ink);text-shadow:2px 2px 0 var(--action-color),-2px -2px 0 var(--action-color),2px -2px 0 var(--action-color),-2px 2px 0 var(--action-color)}#canvas-placeholder{position:absolute;width:calc(100% - 20px);height:calc(100% - 20px);border:4px dashed var(--shadow);border-radius:10px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;cursor:pointer;color:var(--shadow);transition:all .2s;padding:2rem;overflow:hidden;position:relative}#canvas-placeholder h3,#canvas-placeholder p{position:relative;z-index:2}#canvas-placeholder video{position:absolute;top:0;left:0;width:100%;height:100%;-o-object-fit:cover;object-fit:cover;z-index:1;opacity:.6}#canvas-placeholder h3{font-size:2.2rem;margin:0 0 .5rem}#canvas-placeholder p{font-size:1.3rem}#canvas-panel.drag-over #canvas-placeholder,#canvas-placeholder:hover{border-color:var(--ink);color:var(--ink);background-color:rgba(255,255,255,.5)}body[data-theme-is-dark=true] #canvas-panel.drag-over #canvas-placeholder,body[data-theme-is-dark=true] #canvas-placeholder:hover{background-color:rgba(var(--light-rgb),.5)}#canvas-panel.drag-over{background-color:var(--shadow)}#layer-instructions{padding:0 0 .5rem;margin:0;font-size:1.1rem}#mg-preview-container{position:relative;background:var(--light);border:2px solid var(--ink);box-shadow:4px 4px 0 var(--ink);padding:10px}#mg-preview-container .overlay-close-btn{top:-10px;right:-10px;background:var(--danger-color);color:var(--light);border:2px solid var(--ink)}#mg-preview-video{display:block;max-width:80vw;max-height:75vh;background:#000}#mg-generation-overlay{z-index:4000}#mg-generation-overlay .window{max-width:400px;height:auto;padding:2rem;text-align:center;background:rgba(var(--light-rgb),.65);-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px)}#mg-generation-overlay h3{font-size:2rem;margin:0 0 1rem}#mg-generation-overlay h3::after{display:inline-block;animation:ellipsis 1.4s infinite;content:".";width:1em;text-align:left}@keyframes ellipsis{0%{content:"."}33%{content:".."}66%{content:"..."}}#mg-confirmation-overlay{z-index:5000}#mg-confirmation-dialog{padding:1.5rem;text-align:center;width:90%;max-width:400px;height:auto}#mg-confirmation-dialog p{font-size:1.2rem;margin:0 0 1.5rem}#mg-confirmation-dialog .action-buttons{display:flex;justify-content:center}#scene-actions-container{grid-template-columns:2fr 1fr 1fr;gap:.5rem}#scene-actions-container #mg-record-layer-btn{font-size:20px}#mg-gravity-menu.window{position:absolute;z-index:101;background:rgba(var(--light-rgb),.65);-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px);border:2px solid var(--ink);box-shadow:4px 4px 0 var(--ink);padding:.5rem 1rem;width:200px;height:auto;text-align:center;display:none}#mg-gravity-menu h5{margin:0 0 .5rem;font-size:1.2rem;text-align:center}#mg-gravity-menu p{margin:.2rem 0;font-size:1rem;display:flex;align-items:center;justify-content:space-between}#mg-gravity-menu input[type=number]{font-family:inherit;font-size:1rem;padding:4px;border:2px solid var(--ink);background:var(--bg);flex-grow:1;margin-left:.5rem;text-align:center;box-shadow:inset 1px 1px 0 var(--shadow);transition:background-color .3s,border-color .3s,color .3s}#mg-gravity-menu .action-buttons{display:flex;gap:.5rem;margin-top:.5rem;justify-content:space-around}#mg-gravity-menu .mg-btn{padding:4px 10px;font-size:16px;margin:0;width:auto;flex-grow:1}#mg-gravity-menu h5{margin:0 0 .5rem;font-size:1.2rem;text-align:center}#mg-gravity-menu p{margin:.2rem 0;font-size:1rem;display:flex;align-items:center;justify-content:space-between}#mg-gravity-menu input[type=number]{font-family:inherit;font-size:1rem;padding:4px;border:2px solid var(--ink);background:var(--bg);flex-grow:1;margin-left:.5rem;text-align:center;box-shadow:inset 1px 1px 0 var(--shadow)}body[data-theme-is-dark=true] #mg-gravity-menu input[type=number]{border-color:var(--mid);color:var(--ink)}#mg-gravity-menu .action-buttons{display:flex;gap:.5rem;margin-top:.5rem;justify-content:space-around}#mg-gravity-menu .mg-btn{padding:4px 10px;font-size:16px;margin:0;width:auto;flex-grow:1}#text-content,#text-font{transition:background-color .3s,border-color .3s,color .3s}#text-layer-manager{display:flex;gap:.5rem;align-items:center;padding-bottom:.5rem;margin-bottom:.5rem;border-bottom:2px solid var(--mid)}#text-layer-palette{display:flex;gap:.5rem;flex-wrap:wrap;flex-grow:1;min-height:44px}#add-new-text-layer-btn{width:40px;height:40px;flex-shrink:0;font-size:2rem;line-height:1;padding:0}.text-thumb{width:60px;height:40px;display:flex;align-items:center;justify-content:center;overflow:hidden;background-color:var(--ink);color:var(--light);font-size:.8rem;padding:2px;text-align:center}.text-thumb span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;pointer-events:none}.palette-slot.empty:disabled{opacity:.4;cursor:default;pointer-events:none;background-color:var(--light)}.palette-slot.empty:disabled:hover{background-color:var(--light);color:var(--mid)}#audio-btn:disabled,#shortcuts-btn:disabled,#text-btn:disabled,#visuals-btn:disabled{opacity:.5;pointer-events:none;cursor:default}#mg-stacked-layers-palette{display:flex;gap:.5rem;flex-wrap:wrap;min-height:0;align-content:flex-start}.committed-collage-thumb{width:100%;height:100%;display:flex;flex-direction:column;overflow:hidden}.committed-collage-thumb img{width:100%;flex-grow:1;-o-object-fit:cover;object-fit:cover;min-height:0}.layer-thumb.dragging{opacity:.4;transform:rotate(-3deg) scale(1.05);box-shadow:0 8px 20px rgba(0,0,0,.3);cursor:grabbing}.layer-thumb.drag-over{border:3px dashed var(--action-color);transform:scale(1.02);background-color:rgba(var(--action-color-rgb),.1)}#mg-pasteboard-overlay-canvas{position:absolute;pointer-events:none;display:none}#canvas-panel.is-zoomed-out{background-color:var(--shadow)}#mg-controls-overlay-canvas,#mg-movie-canvas,#mg-pasteboard-overlay-canvas{transition:transform .3s ease-in-out,box-shadow .3s ease-in-out}#canvas-panel.is-zoomed-out #mg-controls-overlay-canvas,#canvas-panel.is-zoomed-out #mg-movie-canvas,#canvas-panel.is-zoomed-out #mg-pasteboard-overlay-canvas{transform:scale(.8);box-shadow:0 0 15px rgba(0,0,0,.5)}#canvas-panel.is-zoomed-out #mg-controls-overlay-canvas{display:none}#canvas-panel.is-zoomed-out #mg-pasteboard-overlay-canvas{display:block}#toggle-view-btn:disabled,#toggle-view-btn:disabled:hover{opacity:.5;pointer-events:none;cursor:default}#audio-playback-controls{justify-content:center}#audio-instructions{font-size:.8rem;color:var(--shadow);text-align:center;margin-top:-.5rem;margin-bottom:.5rem}#waveform-time{font-size:.8rem;color:var(--shadow);text-align:center;margin-top:-8px;margin-bottom:10px}.effects-checkbox{display:flex;align-items:center;margin-top:.5rem}.effects-checkbox input{margin-right:.5rem}.effects-controls{padding-left:1.5rem;border-left:2px solid var(--mid);margin-left:.5rem}.effects-controls.disabled{opacity:.5;pointer-events:none}#theme-popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:transparent;display:none;z-index:7000}#theme-popup-content{background:var(--bg);border:2px solid var(--ink);box-shadow:4px 4px 0 var(--shadow);padding:1rem;width:90%;max-width:400px;max-height:80vh;display:flex;flex-direction:column;position:absolute;transition:background-color .3s,border-color .3s,box-shadow .3s}#theme-list{list-style:none;margin:0;padding:0;overflow-y:auto}#theme-list li{padding:.75rem 1rem;cursor:pointer;display:flex;justify-content:space-between;align-items:center;transition:background-color .2s;border-radius:4px}#theme-list li.active{background-color:var(--action-color);color:var(--bg)}#theme-list li.active::before{content:'✓';margin-right:.5rem}#theme-list li:not(.active):hover{background-color:var(--mid)}.theme-colors{display:flex;gap:.5rem}.theme-color-dot{width:16px;height:16px;border-radius:50%;border:2px solid var(--ink)}#version-popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.7);-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px);display:none;justify-content:center;align-items:center;z-index:6000}#version-popup-content{background-color:var(--bg);padding:2rem;border:2px solid var(--ink);box-shadow:4px 4px 0 var(--shadow);width:80%;height:80%;max-width:1200px;position:relative;color:var(--ink);transition:background-color .3s,border-color .3s,box-shadow .3s,color .3s}#close-popup{position:absolute;top:1rem;right:1.5rem;font-size:2rem;color:var(--ink);cursor:pointer;font-family:'VT323',monospace;line-height:1;transition:opacity .2s}#close-popup:hover{opacity:.6}
/* === MODIFIED FOOTER STYLES === */
footer{height:28px;padding:0 8px;display:flex;justify-content:space-between;align-items:center;font-size:.9rem;flex-shrink:0;gap:1rem;background-color:var(--light);color:var(--ink);transition:background-color .3s,color .3s;border-top:none}.footer-links{display:flex;flex-wrap:wrap;gap:1.5rem;align-items:center}.footer-right{display:flex;flex-wrap:wrap;gap:1.5rem;align-items:center}footer a{color:var(--ink);text-decoration:none;transition:opacity .2s,color .3s;opacity:.7}footer a:hover{opacity:1}footer a i{margin-right:.5em}@media (max-width:980px){footer{justify-content:center}}.custom-font-select-container{position:relative;width:100%;font-family:inherit;font-size:1rem}.custom-font-select-trigger{width:100%;padding:4px;border:2px solid var(--ink);background:var(--bg);cursor:pointer;display:flex;justify-content:space-between;align-items:center;transition:background-color .3s,border-color .3s}.custom-font-select-trigger span:first-child{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.custom-font-options{position:absolute;top:100%;left:0;right:0;border:2px solid var(--ink);background:var(--light);z-index:101;max-height:200px;overflow-y:auto;display:none;box-shadow:2px 2px 0 var(--shadow)}.custom-font-option{padding:8px;cursor:pointer;transition:background-color .2s;font-size:1rem}.custom-font-option[data-value="'Press Start 2P', cursive"]{font-size:.8rem}.custom-font-option:hover{background-color:var(--mid)}.custom-font-option.selected{background-color:var(--action-color);color:var(--light)}
/* === ADDED CSS FOR VISUALS TABS === */
.visuals-main-tabs{display:flex;gap:.5rem;margin-bottom:.5rem}.visuals-main-tab-btn{font-family:inherit;font-size:16px;background:var(--light);border:2px solid var(--ink);padding:4px 8px;cursor:pointer;color:var(--ink);transition:.2s all;box-shadow:2px 2px 0 var(--shadow);flex-grow:1;text-align:center}.visuals-main-tab-btn:hover{transform:translate(1px,1px);box-shadow:1px 1px 0 var(--shadow)}.visuals-main-tab-btn.active{background-color:var(--action-color);color:var(--light);transform:translate(2px,2px);box-shadow:none}

/* === NEW: PROJECT LIBRARY STYLES === */
#project-library-assets{display:flex;gap:.5rem;flex-wrap:wrap;min-height:70px;align-content:flex-start}#project-library-popup{width:90%;max-width:800px;height:80vh;padding:0;display:flex;flex-direction:column}#project-library-popup .titlebar{flex-shrink:0}
.project-library-grid{padding:1rem;display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:1rem;align-content:flex-start}
.library-grid-item{width:100%;aspect-ratio:1/1;border:2px solid var(--ink);background:var(--light);position:relative;box-shadow:2px 2px 0 var(--shadow);transition:all .2s}.library-grid-item .delete-btn{position:absolute;top:-8px;right:-8px;background:var(--danger-color);color:var(--light);border:2px solid var(--ink);border-radius:50%;width:24px;height:24px;font-size:16px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-family:monospace;line-height:1;z-index:2;opacity:0;transition:opacity .2s}.library-grid-item:hover .delete-btn{opacity:1}.library-grid-item > div{cursor:pointer}.library-grid-item:hover{transform:scale(1.05);border-color:var(--action-color);box-shadow:4px 4px 0 var(--shadow)}.library-grid-item img,.library-grid-item video{width:100%;height:100%;-o-object-fit:cover;object-fit:cover;pointer-events:none}
</style>
</head>
<body>
<div class=window>
<div id="loading-overlay"><h1>Generating Movie-Maker-Studio.exe</h1></div>
<div class=titlebar><span>Movie-Maker-Studio.exe</span><div class=titlebar-controls>
    <!-- REMOVED OLD THEME TOGGLE BUTTON -->
    <button id="toggle-view-btn" title="Toggle Canvas View (Z)">⬚</button><button id=visuals-btn>Edit Visuals</button><div id=visuals-dropdown><h5>Visuals Editor</h5>
<!-- === NEW VISUALS TAB STRUCTURE === -->
<div class=visuals-main-tabs><button id=asset-tab-btn class="visuals-main-tab-btn active">Asset</button><button id=background-tab-btn class=visuals-main-tab-btn>Background</button></div><div id=asset-tab-content><div id=asset-visuals-controls class=disabled><h6>Filters</h6><div class=slider-container><label for=asset-opacity>Opacity</label><input type=range id=asset-opacity min=0 max=1 step=.01 value=1></div><div class=slider-container><label for=asset-brightness>Brightness</label><input type=range id=asset-brightness min=0 max=2 step=.01 value=1></div><div class=slider-container><label for=asset-saturation>Saturation</label><input type=range id=asset-saturation min=0 max=2 step=.01 value=1></div><h6>Drop Shadow</h6><div class=effects-checkbox><input type=checkbox id=shadow-enable> <label for=shadow-enable>Enable</label></div><div id=shadow-controls class="effects-controls disabled"><div class=slider-container><label for=shadow-color>Color</label> <input type=color id=shadow-color value=#000000></div><div class=slider-container><label for=shadow-blur>Blur</label> <input type=range id=shadow-blur min=0 max=50 value=10></div><div class=slider-container><label for=shadow-offset-x>Offset X</label> <input type=range id=shadow-offset-x min=-50 max=50 value=10></div><div class=slider-container><label for=shadow-offset-y>Offset Y</label> <input type=range id=shadow-offset-y min=-50 max=50 value=10></div></div><h6>Border</h6><div class=effects-checkbox><input type=checkbox id=border-enable> <label for=border-enable>Enable</label></div><div id=border-controls class="effects-controls disabled"><div class=slider-container><label for=border-color>Color</label> <input type=color id=border-color value=#FFFFFF></div><div class=slider-container><label for=border-width>Width</label> <input type=range id=border-width min=0 max=20 value=4></div></div></div></div><div id=background-tab-content class=hidden><div id=background-visuals-controls><h6>Background Filters</h6><div class=slider-container><label for=bg-brightness>Brightness</label><input type=range id=bg-brightness min=0 max=2 step=.01 value=1></div><div class=slider-container><label for=bg-saturation>Saturation</label><input type=range id=bg-saturation min=0 max=2 step=.01 value=1></div></div></div>
<!-- === END VISUALS TAB STRUCTURE === -->
</div><button id=text-btn>Text Layers</button><div id=text-dropdown><h5>Text Editor</h5><div id=text-layer-manager><div id=text-layer-palette></div><button id=add-new-text-layer-btn class="palette-slot empty" title="Add new text layer">+</button></div><div id=text-visuals-controls class=disabled><div class=slider-container><label for=text-content>Text Content</label><textarea id=text-content rows=3 style=width:100%;font-family:inherit;font-size:1rem;padding:4px;border:2px solid var(--ink);background:var(--bg)>New Text</textarea></div>
<div class=slider-container>
    <label for=text-font>Font</label>
    <!-- The original select is now hidden and controlled by the new custom dropdown -->
    <select id="text-font" style="display:none;">
        <option value="'VT323', monospace">VT323</option>
        <option value="'Anton', sans-serif">Anton</option>
        <option value="'Indie Flower', cursive">Indie Flower</option>
        <option value="'Londrina Outline', cursive">Londrina Outline</option>
        <option value="'Patua One', cursive">Patua One</option>
        <option value="'Pixelify Sans', sans-serif">Pixelify Sans</option>
        <option value="'Press Start 2P', cursive">Press Start 2P</option>
        <option value="'Rubik Mono One', sans-serif">Rubik Mono One</option>
        <option value="'Young Serif', serif">Young Serif</option>
        <option value="Georgia, serif">Georgia</option>
        <option value="Times New Roman, serif">Times New Roman</option>
        <option value="Courier New, monospace">Courier New</option>
        <option value="Impact, fantasy">Impact</option>
        <option value="Comic Sans MS, cursive">Comic Sans MS</option>
    </select>
    <!-- NEW: Custom Font Selector HTML -->
    <div id="custom-font-select-container" class="custom-font-select-container">
        <div id="custom-font-select-trigger" class="custom-font-select-trigger">
            <span id="custom-font-select-label">VT323</span>
            <span class="custom-select-arrow">▼</span>
        </div>
        <div id="custom-font-options" class="custom-font-options">
            <!-- Font options will be populated by JavaScript -->
        </div>
    </div>
</div>
<div class=slider-container><label for=text-size>Size</label><input type=range id=text-size min=20 max=800 step=1 value=410></div><div class=slider-container><label for=text-color>Color</label><input type=color id=text-color value=#FFFFFF style=width:100%;border:none;padding:0></div><div class="slider-container"><label for="text-stroke-color">Stroke Color</label><input type="color" id="text-stroke-color" value="#000000" style="width: 100%; border: none; padding: 0;"></div><div class="slider-container"><label for="text-stroke-width">Stroke Width</label><input type="range" id="text-stroke-width" min="0" max="20" step="1" value="0"></div><div class=slider-container><label for=text-opacity>Opacity</label><input type=range id=text-opacity min=0 max=1 step=.01 value=1></div><div class=slider-container><label for=text-brightness>Brightness</label><input type=range id=text-brightness min=0 max=2 step=.01 value=1></div></div></div>
<button id=audio-btn>+ Scene Audio</button>
<div id=audio-dropdown>
    <h5>Scene Audio</h5>
    <div id=audio-controls>
        <div id="waveform" style="border: 1px solid var(--ink); margin-bottom: 10px; min-height: 100px; display: none;"></div>
        <div id="waveform-time" style="display: none;">00:00 / 00:00</div>
        <p id="audio-instructions" style="display: none;">Click on the waveform to choose a start time.</p>
        <div id="waveform-loading" style="display: none; text-align: center; padding: 10px;">Loading waveform...</div>
        <div class="action-buttons" id="audio-playback-controls" style="display: none;">
            <button class="mg-btn" id="play-pause-audio-btn">Play</button>
            <button class="mg-btn" id="set-start-time-btn">Set Start Time</button>
        </div>
        <p id=audio-file-name>No audio added.</p>
        <div class=action-buttons>
            <label class="mg-btn" id="upload-audio-label">Upload <input type=file id=scene-audio-input accept=audio/* style=display:none></label>
            <button class="mg-btn" id=remove-audio-btn disabled>Remove</button>
        </div>
    </div>
</div>
<button id=shortcuts-btn>Shortcuts</button><div class=controls-fake><div class=btn-square></div><div class=btn-square></div></div><div id=shortcuts-dropdown><h5>Keyboard Shortcuts</h5><ul><li><span>Start/Stop Recording</span><kbd>R</kbd></li><li><span>Toggle Canvas View</span><kbd>Z</kbd></li><li><span>Enlarge Asset</span><kbd>D</kbd></li><li><span>Shrink Asset</span><kbd>F</kbd></li><li><span>Flip Asset Horizontally</span><kbd>S</kbd></li><li><span>Move Layer Up/Left</span><kbd>Q</kbd></li><li><span>Move Layer Down/Right</span><kbd>W</kbd></li><li><span>Toggle Gravity Menu</span><kbd>G</kbd></li><li><span>Delete Asset</span><kbd>Delete</kbd></li></ul></div></div></div><main id=studio-container><div id=controls-panel><fieldset><legend>Scenes</legend><div id=scene-tray></div><button class=mg-btn id=add-scene-btn style=margin-top:.5rem title="Add a new scene with an image or video background">+ Create Scene</button></fieldset>
    <!-- === NEW PROJECT LIBRARY SECTION === -->
    <fieldset id="project-library-fieldset"><legend>Project Library</legend><p id="project-library-placeholder" class="placeholder-text">Assets you add will appear here.</p><div id="project-library-assets"></div><button class="mg-btn" id="project-library-see-more" style="display: none; margin-top: 0.5rem; width: 100%;">See More</button></fieldset>
    <!-- === END NEW PROJECT LIBRARY SECTION === -->
<fieldset id="layers-fieldset"><legend>Layers</legend><p id=layer-instructions class=placeholder-text>Create a scene to begin.</p><div id=mg-asset-palette></div></fieldset>
            <fieldset id="stack-assets-fieldset" class="hidden"><legend>Multi-asset Layering</legend>
                <p class="placeholder-text" style="margin-top: -0.5rem; margin-bottom: 0.8rem;">
                    Click & drag assets to re-order your stack. The top-left is the highest layer.
                </p>
                <div id="mg-stacked-layers-palette"></div>
            </fieldset>

<fieldset><legend>Current Scene</legend><div class=scene-controls-container><div id=scene-actions-container class=action-buttons><button class="mg-btn record" id=mg-record-layer-btn disabled>Record Layer</button><button class=mg-btn id=mg-preview-scene-btn disabled>Preview Scene</button><button class=mg-btn id=mg-delete-scene-btn disabled>Delete Scene</button></div><div id=stop-actions-container class="action-buttons hidden"><button class="mg-btn active" id=mg-stop-layer-btn style=grid-column:span 2>Stop</button></div><div id=recording-status class=hidden><div id=recording-indicator></div><span id=recording-timer>00:00</span></div><button class="mg-btn hidden" id=mg-commit-layer-btn>Commit Layer & Add Next</button></div></fieldset><fieldset><legend>Project</legend><button class="mg-btn generate" id=mg-generate-project-btn disabled>Generate Project</button><div class=action-buttons id=post-generation-actions style=margin-top:.5rem><button class="mg-btn hidden" id=mg-preview-btn>Preview</button><button class="mg-btn hidden" id=mg-movie-download>Download</button></div></fieldset></div><div id=canvas-panel><canvas id=mg-movie-canvas></canvas><canvas id=mg-controls-overlay-canvas></canvas><canvas id="mg-pasteboard-overlay-canvas"></canvas><div id=canvas-placeholder><video src=welcomevid.mp4 autoplay loop muted playsinline></video><h3>Click, Paste, or Drag & Drop File</h3><p>to add a background image or video &amp; begin creating</p></div></div></main><input type=file id=initial-background-input accept=image/*,video/* style=display:none>
<!-- === FOOTER MOVED INSIDE .window === -->
<footer><div class=footer-links><a href=#><i class="fas fa-envelope"></i>feedback</a> <a href=#><i class="fab fa-twitter"></i>updates</a> <a href=#><i class="fas fa-file-alt"></i>license</a> <a href=#><i class="fas fa-shield-alt"></i>report</a> <a href=#><i class="fas fa-lock"></i>privacy</a></div><div class=footer-right><a href=# id=theme-select-link><i class="fas fa-palette"></i><span id=current-theme-name></span></a> <a href=# id=version-link><i class="fas fa-code-branch"></i>v4.18.0</a></div></footer></div>
<!-- === REVISED ASSET LIBRARY POPUP === -->
<div id="mg-asset-library-overlay" class="mg-overlay-base">
    <div id="mg-asset-picker-wrapper" class="window">
        <button id="mg-asset-library-close" class="overlay-close-btn">X</button>
        <h4>Add a New Layer</h4>
        <p>Add your own image or video to the current scene.</p>
        <div id="mg-asset-drop-zone">
            <h3>Click, Paste, or Drag & Drop File</h3>
            <p>Supported formats: PNG, MP4, MOV</p>
        </div>
        <!-- The file input is now triggered by JS, so it doesn't need to be visible -->
        <div id="mg-asset-picker-actions">
            <input type="file" id="mg-asset-picker-file" accept="image/png,video/mp4,video/quicktime,video/*" style="display:none">
        </div>
    </div>
</div>
<div id=mg-preview-popup class=mg-overlay-base><div id=mg-preview-container><button id=mg-preview-close-btn class=overlay-close-btn>X</button><video id=mg-preview-video controls autoplay></video></div></div><div id=mg-generation-overlay class=mg-overlay-base><div class=window><h3>Generating Project</h3><p>Please wait while your scene(s) are combined into the final video.</p></div></div><div id=mg-confirmation-overlay class=mg-overlay-base><div id=mg-confirmation-dialog class=window><p id=mg-confirmation-text>Are you sure?</p><div class=action-buttons><button id=mg-confirm-yes-btn class="mg-btn active">Yes</button><button id=mg-confirm-no-btn class=mg-btn>No</button></div></div></div><div id=mg-gravity-menu class="window hidden"><h5>Set Motion</h5><p id=gravity-instructions style="font-size:.9rem;margin-bottom:.5rem;color:var(--ink);min-height:30px;display:flex;align-items:center;justify-content:center"></p><p>Gravity: <input type=number id=gravity-input value=0 step=.1 style=width:100px></p><p>Rotation: <input type=number id="gravity-rotation-rate" value=0 step=1 style="width:60px;margin-right:4px"> deg/s</p><p style="font-size:.8rem;margin:-.1rem 0 .5rem">(Use negative for CCW)</p><div class=action-buttons><button class=mg-btn id=apply-gravity-btn>Apply</button><button class=mg-btn id=cancel-gravity-btn>Cancel</button></div></div><div id=mg-toast></div><div id=mg-countdown-overlay class=hidden><span id=mg-countdown-span>3</span></div>

<!-- === ADDED VERSION POPUP HTML === -->
<div id="version-popup-overlay">
    <div id="version-popup-content">
        <span id="close-popup">X</span>
        <!-- You can add your dev notes/updates here -->
    </div>
</div>
<!-- === ADDED THEME SELECTOR POPUP HTML === -->
<div id="theme-popup-overlay">
    <div id="theme-popup-content">
        <ul id="theme-list"></ul>
    </div>
</div>

<!-- === NEW: PROJECT LIBRARY POPUP HTML === -->
<div id="project-library-popup-overlay" class="mg-overlay-base">
    <div id="project-library-popup" class="window">
        <button id="project-library-popup-close" class="overlay-close-btn">X</button>
        <div class="titlebar">
            <span>Project Library</span>
        </div>
        <!-- TABS ADDED -->
        <div class="library-tabs" style="padding: 0.5rem 1rem; display: flex; gap: 0.5rem; border-bottom: 2px solid var(--ink);">
            <button id="library-tab-assets" class="visuals-main-tab-btn active">Assets</button>
            <button id="library-tab-backgrounds" class="visuals-main-tab-btn">Backgrounds</button>
        </div>
        <!-- GRIDS CONTAINER ADDED -->
        <div id="project-library-grids-container" style="flex-grow: 1; overflow-y: auto;">
            <div id="project-library-grid-assets" class="project-library-grid">
                <!-- Asset items will be populated here -->
            </div>
            <div id="project-library-grid-backgrounds" class="project-library-grid hidden">
                <!-- Background items will be populated here -->
            </div>
        </div>
    </div>
</div>

</body>
</html>
<script>
    // --- IndexedDB Module with Hashing ---
    const DB_NAME = 'movie-meme-maker-assets-db';
    const STORE_NAME = 'user-assets';
    const DB_VERSION = 1;

    /**
     * Calculates the SHA-256 hash of a file.
     * @param {File} file The file to hash.
     * @returns {Promise<string>} A promise that resolves with the hex string of the hash.
     */
    async function calculateFileHash(file) {
        const buffer = await file.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    /**
     * Opens and sets up the IndexedDB database.
     * @returns {Promise<IDBDatabase>} A promise that resolves with the database connection.
     */
    function openDatabase() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = event => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    store.createIndex('hash', 'hash', { unique: true });
                }
            };
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * Saves an asset file and its hash to the IndexedDB.
     * @param {File} file The file object to save.
     * @param {string} hash The SHA-256 hash of the file.
     * @param {string} type The type of asset ('asset' or 'background').
     * @returns {Promise<number>} A promise that resolves with the ID of the new record.
     */
    async function saveAssetToDB(file, hash, type = 'asset') {
        const db = await openDatabase();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.add({ file: file, name: file.name, hash: hash, type: type, createdAt: new Date() });
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }
    
    /**
     * Retrieves an asset record from the database by its hash.
     * @param {string} hash The hash of the asset to find.
     * @returns {Promise<Object|undefined>} A promise that resolves with the record or undefined if not found.
     */
    async function getAssetByHash(hash) {
        const db = await openDatabase();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const index = store.index('hash');
            const request = index.get(hash);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }


    /**
     * Retrieves all asset records from the database.
     * @returns {Promise<Array<Object>>} A promise that resolves with an array of all records.
     */
    async function getAllAssetsFromDB() {
        const db = await openDatabase();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * Deletes an asset record from the database by its ID.
     * @param {number} id The unique ID of the asset record to delete.
     * @returns {Promise<void>}
     */
    async function deleteAssetFromDB(id) {
        const db = await openDatabase();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.delete(id);
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }


    (function () {
        // --- START OF NEW THEME SELECTOR LOGIC ---
        const themes = {
            'classic light': {
                name: 'classic light', isDark: false, colors: ['#f2efe8', '#2b2b2b', '#c2c2c2'],
                css: { '--bg': '#f2efe8', '--ink': '#2b2b2b', '--mid': '#c2c2c2', '--light': '#faf9f5', '--shadow': '#7a7a7a', '--action-color': '#4477cc', '--danger-color': '#cc4444', '--success-color': '#55cc55' }
            },
            'dark': {
                name: 'dark', isDark: true, colors: ['#1a1d2d', '#e0e5f0', '#5a8de8'],
                css: { '--bg': '#1a1d2d', '--ink': '#e0e5f0', '--mid': '#3d4a6e', '--light': '#252a40', '--shadow': '#0d0f16', '--action-color': '#5a8de8', '--danger-color': '#a83e3e', '--success-color': '#4a9d4a' }
            },
            'zarah': { // formerly botanical
                name: 'zarah', isDark: false, colors: ['#7b9c98', '#eaf1f3', '#495755'],
                css: { '--bg': '#7b9c98', '--ink': '#eaf1f3', '--mid': '#495755', '--light': '#6c8985', '--shadow': '#3e4a48', '--action-color': '#eaf1f3' }
            },
            'denim': { // formerly dracula
                name: 'denim', isDark: true, colors: ['#282a36', '#f8f82', '#bd93f9'],
                css: { '--bg': '#282a36', '--ink': '#f8f8f2', '--mid': '#44475a', '--light': '#383a59', '--shadow': '#21222c', '--action-color': '#bd93f9' }
            },
            'lavender': { // formerly lilac mist
                name: 'lavender', isDark: false, colors: ['#b3b3d9', '#282846', '#656599'],
                css: { '--bg': '#b3b3d9', '--ink': '#282846', '--mid': '#656599', '--light': '#c4c4e2', '--shadow': '#47476b', '--action-color': '#8c58a6' }
            },
            'café': {
                name: 'café', isDark: false, colors: ['#ceb18d', '#4e433f', '#d4d2d1'],
                css: { '--bg': '#ceb18d', '--ink': '#4e433f', '--mid': '#d4d2d1', '--light': '#f7f2ea', '--shadow': '#8a7a6a', '--action-color': '#8a6ea2' }
            },
            'mizu': {
                name: 'mizu', isDark: false, colors: ['#b8dceb', '#091f2c', '#89a5bb'],
                css: { '--bg': '#b8dceb', '--ink': '#091f2c', '--mid': '#89a5bb', '--light': '#cfe5ee', '--shadow': '#627382', '--action-color': '#005a8e' }
            },
            'キティ': { // formerly solarized light
                name: 'キティ', isDark: false, colors: ['#fdf6e3', '#657b83', '#93a1a1'],
                css: { '--bg': '#fdf6e3', '--ink': '#657b83', '--mid': '#93a1a1', '--light': '#eee8d5', '--shadow': '#586e75', '--action-color': '#268bd2' }
            },
            'イーピーイッピ': { // formerly serika dark
                name: 'イーピーイッピ', isDark: true, colors: ['#323437', '#e2b714', '#646669'],
                css: { '--bg': '#323437', '--ink': '#e2b714', '--mid': '#646669', '--light': '#414447', '--shadow': '#212324', '--action-color': '#ca4754' }
            },
            'aura': { // formerly aurora
                name: 'aura', isDark: true, colors: ['#011926', '#ffca3a', '#23395b'],
                css: { '--bg': '#011926', '--ink': '#ffca3a', '--mid': '#23395b', '--light': '#0a1f33', '--shadow': '#000d14', '--action-color': '#00e980' }
            },
        };

        const themePopupOverlay = document.getElementById('theme-popup-overlay');
        const themePopupContent = document.getElementById('theme-popup-content');
        const themeList = document.getElementById('theme-list');
        const themeSelectLink = document.getElementById('theme-select-link');
        const currentThemeNameSpan = document.getElementById('current-theme-name');
        const versionLink = document.getElementById('version-link');
        const versionPopupOverlay = document.getElementById('version-popup-overlay');
        const closeVersionPopupBtn = document.getElementById('close-popup');

        function applyTheme(themeName) {
            const theme = themes[themeName];
            if (!theme) return;
            const root = document.documentElement;
            for (const [key, value] of Object.entries(theme.css)) {
                root.style.setProperty(key, value);
                if (key === '--light') root.style.setProperty('--light-rgb', hexToRgb(value));
                if (key === '--bg') root.style.setProperty('--bg-rgb', hexToRgb(value));
                if (key === '--action-color') root.style.setProperty('--action-color-rgb', hexToRgb(value));
            }
            document.body.dataset.themeIsDark = theme.isDark;
        }

        function hexToRgb(hex) {
            let r = 0, g = 0, b = 0;
            if (hex.length == 4) { r = parseInt(hex[1] + hex[1], 16); g = parseInt(hex[2] + hex[2], 16); b = parseInt(hex[3] + hex[3], 16); }
            else if (hex.length == 7) { r = parseInt(hex[1] + hex[2], 16); g = parseInt(hex[3] + hex[4], 16); b = parseInt(hex[5] + hex[6], 16); }
            return `${r},${g},${b}`;
        }

        function confirmAndSaveTheme(themeName) {
            applyTheme(themeName);
            localStorage.setItem('selectedTheme', themeName);
            currentThemeNameSpan.textContent = themeName;
            const currentActive = themeList.querySelector('.active');
            if (currentActive) currentActive.classList.remove('active');
            const newActive = themeList.querySelector(`[data-theme-name="${themeName}"]`);
            if (newActive) newActive.classList.add('active');
            themePopupOverlay.style.display = 'none';
        }

        function populateThemeList() {
            themeList.innerHTML = '';
            const currentTheme = localStorage.getItem('selectedTheme') || 'classic light';
            for (const themeName in themes) {
                const theme = themes[themeName];
                const li = document.createElement('li');
                li.dataset.themeName = themeName;
                if(themeName === currentTheme) li.classList.add('active');
                
                li.addEventListener('mouseenter', () => applyTheme(themeName));
                
                let content = `<span>${theme.name}</span>`;
                let colorDots = '<div class="theme-colors">';
                theme.colors.forEach(color => {
                    colorDots += `<div class="theme-color-dot" style="background-color: ${color};"></div>`;
                });
                colorDots += '</div>';
                li.innerHTML = content + colorDots;
                li.addEventListener('click', () => confirmAndSaveTheme(themeName));
                themeList.appendChild(li);
            }
        }
        
        themeSelectLink.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const isVisible = themePopupOverlay.style.display === 'block';

            if (isVisible) {
                const savedTheme = localStorage.getItem('selectedTheme') || 'classic light';
                applyTheme(savedTheme);
                themePopupOverlay.style.display = 'none';
            } else {
                populateThemeList();
                const linkRect = themeSelectLink.getBoundingClientRect();
                const footerRect = themeSelectLink.closest('footer').getBoundingClientRect();
                
                themePopupContent.style.bottom = `${window.innerHeight - footerRect.top + 10}px`;
                themePopupContent.style.right = `${window.innerWidth - linkRect.right}px`;
                
                themePopupOverlay.style.display = 'block';
            }
        });

        themeList.addEventListener('mouseleave', () => {
             const savedTheme = localStorage.getItem('selectedTheme') || 'classic light';
             applyTheme(savedTheme);
        });

        document.addEventListener('click', (e) => {
            if (themePopupOverlay.style.display === 'block') {
                const isClickInside = themePopupContent.contains(e.target) || themeSelectLink.contains(e.target);
                if (!isClickInside) {
                     const savedTheme = localStorage.getItem('selectedTheme') || 'classic light';
                     applyTheme(savedTheme);
                     themePopupOverlay.style.display = 'none';
                }
            }
        });
        // --- END OF NEW THEME SELECTOR LOGIC ---


        // --- Preloader Logic ---
        const loadingOverlay = document.getElementById('loading-overlay');
        setTimeout(() => {
            loadingOverlay.style.opacity = '0';
            setTimeout(() => {
                loadingOverlay.style.display = 'none';
            }, 500);
        }, 2500);

        // --- Variable Declarations ---
        const addSceneBtn = document.getElementById('add-scene-btn');
        const assetLibraryOverlay = document.getElementById('mg-asset-library-overlay');
        const assetPalette = document.getElementById('mg-asset-palette');
        const assetPickerFileInput = document.getElementById('mg-asset-picker-file');
        const canvasPanel = document.getElementById('canvas-panel');
        const controlsPanel = document.getElementById('controls-panel');
        const canvasPlaceholder = document.getElementById('canvas-placeholder');
        const controlsOverlayCanvas = document.getElementById('mg-controls-overlay-canvas');
        const controlsCtx = controlsOverlayCanvas.getContext('2d');
        const pasteboardOverlayCanvas = document.getElementById('mg-pasteboard-overlay-canvas');
        const pasteboardCtx = pasteboardOverlayCanvas.getContext('2d');
        const PASTEBOARD_MARGIN = 500;
        const countdownOverlay = document.getElementById('mg-countdown-overlay');
        const countdownSpan = document.getElementById('mg-countdown-span');
        const initialBackgroundInput = document.getElementById('initial-background-input');
        const layerInstructions = document.getElementById('layer-instructions');
        const movieCanvas = document.getElementById('mg-movie-canvas');
        const movieCtx = movieCanvas.getContext('2d');
        const movieDownloadBtn = document.getElementById('mg-movie-download');
        const recordLayerBtn = document.getElementById('mg-record-layer-btn');
        const stopLayerBtn = document.getElementById('mg-stop-layer-btn');
        const sceneActionsContainer = document.getElementById('scene-actions-container');
        const stopActionsContainer = document.getElementById('stop-actions-container');
        const commitLayerBtn = document.getElementById('mg-commit-layer-btn');
        const recordingStatus = document.getElementById('recording-status');
        const recordingTimer = document.getElementById('recording-timer');
        const sceneTray = document.getElementById('scene-tray');
        const newSceneBackgroundInput = document.createElement('input');
        newSceneBackgroundInput.type = 'file';
        newSceneBackgroundInput.accept = 'image/*,video/*';
        const recordingCanvas = document.createElement('canvas');
        const recordingCtx = recordingCanvas.getContext('2d', {
            alpha: false,
            colorSpace: 'srgb'
        });
        recordingCtx.imageSmoothingEnabled = true;
        recordingCtx.imageSmoothingQuality = 'high';
        const previewBtn = document.getElementById('mg-preview-btn');
        const previewSceneBtn = document.getElementById('mg-preview-scene-btn');
        const previewPopup = document.getElementById('mg-preview-popup');
        const previewVideo = document.getElementById('mg-preview-video');
        const generateProjectBtn = document.getElementById('mg-generate-project-btn');
        const generationOverlay = document.getElementById('mg-generation-overlay');
        const postGenerationActions = document.getElementById('post-generation-actions');
        const deleteSceneBtn = document.getElementById('mg-delete-scene-btn');
        const confirmationOverlay = document.getElementById('mg-confirmation-overlay');
        const confirmationText = document.getElementById('mg-confirmation-text');
        const confirmYesBtn = document.getElementById('mg-confirm-yes-btn');
        const confirmNoBtn = document.getElementById('mg-confirm-no-btn');
        const shortcutsBtn = document.getElementById('shortcuts-btn');
        const shortcutsDropdown = document.getElementById('shortcuts-dropdown');
        const visualsBtn = document.getElementById('visuals-btn');
        const visualsDropdown = document.getElementById('visuals-dropdown');
        const assetVisualsControls = document.getElementById('asset-visuals-controls');
        const assetOpacitySlider = document.getElementById('asset-opacity');
        const assetBrightnessSlider = document.getElementById('asset-brightness');
        const assetSaturationSlider = document.getElementById('asset-saturation');
        const bgBrightnessSlider = document.getElementById('bg-brightness');
        const bgSaturationSlider = document.getElementById('bg-saturation');
        const audioBtn = document.getElementById('audio-btn');
        const audioDropdown = document.getElementById('audio-dropdown');
        const audioControls = document.getElementById('audio-controls');
        const sceneAudioInput = document.getElementById('scene-audio-input');
        const uploadAudioLabel = document.getElementById('upload-audio-label');
        const removeAudioBtn = document.getElementById('remove-audio-btn');
        const audioFileName = document.getElementById('audio-file-name');
        const textBtn = document.getElementById('text-btn');
        const textDropdown = document.getElementById('text-dropdown');
        const textVisualsControls = document.getElementById('text-visuals-controls');
        const textContentInput = document.getElementById('text-content');
        const textFontSelect = document.getElementById('text-font');
        const textSizeSlider = document.getElementById('text-size');
        const textColorInput = document.getElementById('text-color');
        const textStrokeColorInput = document.getElementById('text-stroke-color');
        const textStrokeWidthSlider = document.getElementById('text-stroke-width');
        const textOpacitySlider = document.getElementById('text-opacity');
        const textBrightnessSlider = document.getElementById('text-brightness');
        const addNewTextLayerBtn = document.getElementById('add-new-text-layer-btn');
        const textLayerPalette = document.getElementById('text-layer-palette');
        const toggleViewBtn = document.getElementById('toggle-view-btn');
        
        const shadowEnable = document.getElementById('shadow-enable');
        const shadowControls = document.getElementById('shadow-controls');
        const shadowColor = document.getElementById('shadow-color');
        const shadowBlur = document.getElementById('shadow-blur');
        const shadowOffsetX = document.getElementById('shadow-offset-x');
        const shadowOffsetY = document.getElementById('shadow-offset-y');
        const borderEnable = document.getElementById('border-enable');
        const borderControls = document.getElementById('border-controls');
        const borderColor = document.getElementById('border-color');
        const borderWidth = document.getElementById('border-width');

        // === NEW: PROJECT LIBRARY VARIABLES ===
        const projectLibraryAssetsContainer = document.getElementById('project-library-assets');
        const projectLibrarySeeMoreBtn = document.getElementById('project-library-see-more');
        const projectLibraryPopupOverlay = document.getElementById('project-library-popup-overlay');
        const projectLibraryPopupCloseBtn = document.getElementById('project-library-popup-close');
        const projectLibraryGridAssets = document.getElementById('project-library-grid-assets');
        const projectLibraryGridBackgrounds = document.getElementById('project-library-grid-backgrounds');
        const projectLibraryPlaceholder = document.getElementById('project-library-placeholder');
        const libraryTabAssets = document.getElementById('library-tab-assets');
        const libraryTabBackgrounds = document.getElementById('library-tab-backgrounds');

        let projectLibrary = []; // For type 'asset'
        let projectLibraryBackgrounds = []; // For type 'background'

        let isCanvasViewZoomedOut = false;
        const DAMPING_FACTOR = 0.5;
        const RESIZE_SPEED = 1.546875;
        const assetCache = {};
        let scenes = [];
        let activeSceneId = null;
        let lastRecordingDurationMs = 0;
        let activeMovieLayerId = null;
        let movieInteraction = { active: false };
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let isCountdownActive = false;
        let layerRecordingUrl = null;
        let layerRecordingBlobType = 'video/mp4';
        let animationFrameId = null;
        let recordingIntervalId = null;
        let recordingStartTime = 0;
        let lastRecordingFrameTime = 0;
        const RECORDING_FPS = 30;
        const recordingFrameInterval = 1000 / RECORDING_FPS;
        let resizeState = { isResizing: false, direction: 0, animationFrameId: null };
        let isDraggingSlider = false;
        let masterWidth = 1024;
        let masterHeight = 576;
        let projectileVectorStart = null;
        let projectileVectorEnd = null;
        const VELOCITY_MULTIPLIER = 0.15;
        const PROJECTILE_HANDLE_SIZE = 20;
        const PROJECTILE_HANDLE_OFFSET = 15;
        const gravityMenu = document.getElementById('mg-gravity-menu');
        const gravityInput = document.getElementById('gravity-input');
        const applyGravityBtn = document.getElementById('apply-gravity-btn');
        const cancelGravityBtn = document.getElementById('cancel-gravity-btn');
        const gravityInstructions = document.getElementById('gravity-instructions');
        const GRAVITY_TRAJECTORY_STEPS = 50;
        const TRAJECTORY_TIME_SCALING_FACTOR = 0.2;
        const MAX_TRAJECTORY_TIME_SECONDS = 15;
        let wavesurfer = null;
        let selectedAudioStartTime = 0;
        let originalFontBeforeHover = null; 

        // --- NEW: On-Demand Library/Asset Loading ---
        let areFontsLoaded = false;
        function loadGoogleFonts() {
            if (areFontsLoaded) return;
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = 'https://fonts.googleapis.com/css2?family=Anton&family=Indie+Flower&family=Londrina+Outline&family=Patua+One&family=Pixelify+Sans&family=Press+Start+2P&family=Roboto:wght@400;700&family=Rubik+Mono+One&family=Young+Serif&display=swap';
            document.head.appendChild(link);
            areFontsLoaded = true;
        }

        let isWaveSurferLoaded = false;
        function loadWaveSurfer() {
            if (isWaveSurferLoaded) return;
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/wavesurfer.js';
            document.body.appendChild(script);
            isWaveSurferLoaded = true;
        }

        const getCurrentScene = () => scenes.find(s => s.id === activeSceneId);
        const getActiveLayer = () => getCurrentScene()?.layers.find(l => l.id === activeMovieLayerId);
        
        function hidePostGenerationActions() {
            const downloadBtn = document.getElementById('mg-movie-download');
            const previewBtn = document.getElementById('mg-preview-btn');
            const postGenActions = document.getElementById('post-generation-actions');

            if (downloadBtn.dataset.downloadUrl) {
                URL.revokeObjectURL(downloadBtn.dataset.downloadUrl);
            }

            postGenActions.classList.add('hidden');
            previewBtn.classList.add('hidden');
            downloadBtn.classList.add('hidden');
            
            downloadBtn.removeAttribute('data-download-url');
            previewBtn.removeAttribute('data-preview-url');
        }

        function getDominantColor(element) {
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            tempCanvas.width = 1;
            tempCanvas.height = 1;
            ctx.drawImage(element, 0, 0, 1, 1);
            const data = ctx.getImageData(0, 0, 1, 1).data;
            return `${data[0]}, ${data[1]}, ${data[2]}`;
        }
        
        function createLibraryThumb(asset, thumbClass) {
            const thumb = document.createElement('div');
            thumb.className = thumbClass;
            
            const content = document.createElement('div');
            content.style.width = '100%';
            content.style.height = '100%';
            content.title = `Use this ${asset.type}`;
            
            if (asset.file && asset.file.type.startsWith('video/')) {
                content.innerHTML = `<video src="${asset.src}" muted playsinline></video>`;
                setTimeout(() => {
                    const video = content.querySelector('video');
                    if (video) video.currentTime = 0.1;
                }, 100);
            } else {
                content.innerHTML = `<img src="${asset.src}" alt="${asset.name}">`;
            }

            content.addEventListener('click', () => {
                if (asset.type === 'background') {
                    const mode = scenes.length === 0 ? 'initial' : 'add';
                    handleBackgroundUpload(asset.file, mode, false, true);
                } else {
                    const mediaType = asset.file.type.startsWith('video/') ? 'video' : 'image';
                    addMovieLayer(asset.src, { type: mediaType });
                }

                if (projectLibraryPopupOverlay.classList.contains('visible')) {
                    projectLibraryPopupOverlay.classList.remove('visible');
                }
            });

            thumb.appendChild(content);

            if (thumbClass === 'library-grid-item') {
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.title = `Delete ${asset.name} from storage`;
                deleteBtn.dataset.id = asset.id;

                deleteBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const assetId = parseInt(e.target.dataset.id, 10);
                    const isAsset = projectLibrary.some(a => a.id === assetId);
                    const assetToDelete = isAsset ? projectLibrary.find(a => a.id === assetId) : projectLibraryBackgrounds.find(a => a.id === assetId);

                    if (assetToDelete) {
                        try {
                            await deleteAssetFromDB(assetId);
                            URL.revokeObjectURL(assetToDelete.src);
                            
                            if(isAsset) {
                                projectLibrary = projectLibrary.filter(a => a.id !== assetId);
                            } else {
                                projectLibraryBackgrounds = projectLibraryBackgrounds.filter(a => a.id !== assetId);
                            }
                            
                            toast(`Deleted ${assetToDelete.name}`, 2000);
                            
                            updateProjectLibraryDisplay();
                            populateProjectLibraryPopup();

                        } catch (error) {
                            console.error('Failed to delete asset:', error);
                            toast('Error deleting asset.', 3000);
                        }
                    }
                });
                thumb.appendChild(deleteBtn);
            }

            return thumb;
        }
        
        function updateProjectLibraryDisplay() {
            projectLibraryAssetsContainer.innerHTML = '';

            if (projectLibrary.length === 0) {
                projectLibraryPlaceholder.style.display = 'block';
                projectLibrarySeeMoreBtn.style.display = 'none';
                return;
            }

            projectLibraryPlaceholder.style.display = 'none';
            const recentAssets = projectLibrary.slice(0, 4);
            recentAssets.forEach(asset => {
                const thumb = createLibraryThumb(asset, 'layer-thumb');
                projectLibraryAssetsContainer.appendChild(thumb);
            });

            const totalAssets = projectLibrary.length + projectLibraryBackgrounds.length;
            projectLibrarySeeMoreBtn.style.display = totalAssets > 4 ? 'block' : 'none';
        }

        function populateProjectLibraryPopup() {
            projectLibraryGridAssets.innerHTML = '';
            projectLibraryGridBackgrounds.innerHTML = '';

            if (projectLibrary.length === 0) {
                 projectLibraryGridAssets.innerHTML = '<p class="placeholder-text">No saved assets.</p>';
            } else {
                projectLibrary.forEach(asset => {
                    const thumb = createLibraryThumb(asset, 'library-grid-item');
                    projectLibraryGridAssets.appendChild(thumb);
                });
            }
            
            if (projectLibraryBackgrounds.length === 0) {
                 projectLibraryGridBackgrounds.innerHTML = '<p class="placeholder-text">No saved backgrounds.</p>';
            } else {
                projectLibraryBackgrounds.forEach(bg => {
                    const thumb = createLibraryThumb(bg, 'library-grid-item');
                    projectLibraryGridBackgrounds.appendChild(thumb);
                });
            }
        }

        function addMovieLayer(src, properties = {}) {
            const currentScene = getCurrentScene();
            if (!currentScene) {
                toast('Please add a background to create a scene first.', 3000);
                initialBackgroundInput.click();
                
                if (assetLibraryOverlay.classList.contains('visible')) {
                    closeAssetLibrary();
                }
                 if (projectLibraryPopupOverlay.classList.contains('visible')) {
                    projectLibraryPopupOverlay.classList.remove('visible');
                }
                return;
            }

            const assetType = properties.type || 'image';

            const createLayer = (element) => {
                const scene = getCurrentScene();
                if (!scene) return;
                if (assetType === 'video') {
                    element.preload = 'auto';
                    element.muted = true;
                    element.playsinline = true;
                    element.loop = true;
                    const prime = () => {
                        try { element.currentTime = 0.001 } catch (e) {}
                        element.play().catch(() => {})
                    };
                    if (element.readyState >= 2) {
                        prime()
                    } else {
                        element.addEventListener('loadeddata', prime, {once: true})
                    }
                }
                const newLayer = {
                    id: (Date.now() + Math.random()).toString(),
                    src,
                    asset: element,
                    type: assetType,
                    x: properties.x || movieCanvas.width / 2,
                    y: properties.y || movieCanvas.height / 2,
                    size: properties.size || movieCanvas.width * 0.25,
                    rot: properties.rot || 0,
                    flipX: false,
                    targetOpacity: 1,
                    opacity: 0,
                    fadeInStartTime: Date.now(),
                    brightness: 1,
                    saturation: 1,
                    shadow: { enabled: false, color: '#000000', blur: 10, offsetX: 10, offsetY: 10 },
                    border: { enabled: false, color: '#FFFFFF', width: 4 },
                    isProjectileActive: false,
                    projectileVectorX: 0,
                    projectileVectorY: 0,
                    projectileStartX: 0,
                    projectileStartY: 0,
                    projectileTimestamp: 0,
                    projectileInitialRotation: 0,
                    projectileInitialFlipX: false,
                    gravityValue: 0,
                    projectileRotationRate: 0,
                    committed: false,
                };

                const visualLayers = scene.layers.filter(l => l.type !== 'text' && !l.committed);
                const isFirstAsset = visualLayers.length === 0;

                const otherLayers = scene.layers.filter(l => l.type === 'text' || l.committed);
                scene.layers = [newLayer, ...visualLayers, ...otherLayers];

                activeMovieLayerId = newLayer.id;
                
                renderLayerPalette();
                renderStackedLayersPalette(); 
                updateControlsState();
                updateEditPanelsUI();
                if (getCurrentScene()) getCurrentScene().layerStartingStates = null;
                toast('Asset Added! Ready to record.', 3000);

                if (isFirstAsset) {
                    setTimeout(() => {
                        const layersFieldset = document.getElementById('layers-fieldset'); 
                        if (layersFieldset) {
                            layersFieldset.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }, 100); 
                }
            };
            if (assetCache[src]) {
                const cached = assetCache[src];
                if (assetType === 'video') {
                    cached.preload = 'auto';
                    cached.muted = true;
                    cached.playsinline = true;
                    cached.loop = true;
                    try { cached.currentTime = 0.001 } catch (e) {}
                    cached.play().catch(() => {})
                }
                createLayer(cached);
                return
            }
            if (assetType === 'image') {
                const image = new Image();
                image.onload = () => { assetCache[src] = image; createLayer(image) };
                image.onerror = () => toast(`Could not load asset: ${src}`);
                image.src = src
            } else if (assetType === 'video') {
                const video = document.createElement('video');
                video.preload = 'auto';
                video.muted = true;
                video.playsinline = true;
                video.loop = true;
                const onLoaded = () => { assetCache[src] = video; createLayer(video) };
                video.addEventListener('loadeddata', onLoaded, {once: true});
                video.onerror = () => toast(`Could not load video asset: ${src}`);
                video.src = src
            }
        }

        function updateCanvasPanelBackground(scene) {
            if (scene && scene.dominantColor) {
                canvasPanel.style.backgroundColor = `rgba(${scene.dominantColor}, 0.4)`;
                canvasPanel.style.backdropFilter = 'blur(15px)';
                canvasPanel.style.webkitBackdropFilter = 'blur(15px)';
            } else {
                canvasPanel.style.backgroundColor = '';
                canvasPanel.style.backdropFilter = '';
                canvasPanel.style.webkitBackdropFilter = '';
            }
        }


        let toastTimeoutId;
        const toast = (msg, duration = 4000) => {
            const t = document.getElementById('mg-toast');
            clearTimeout(toastTimeoutId);
            t.textContent = msg;
            t.style.opacity = 1;
            t.style.visibility = 'visible';
            if (duration !== null) {
                toastTimeoutId = setTimeout(() => {
                    t.style.opacity = 0;
                    t.style.visibility = 'hidden'
                }, duration)
            }
        };

        function getMediaDurationMs(el, type) {
            if (type === 'video' && el && !Number.isNaN(el.duration) && el.duration > 0) {
                return Math.floor(el.duration * 1000)
            }
            return 3000
        }

        function ensureSceneDurationMs(scene, candidateMs) {
            const cand = Math.max(0, candidateMs || 0);
            const prev = Math.max(0, scene.durationMs || 0);
            scene.durationMs = Math.max(prev, cand)
        }

        function padRecordingUntil(targetMs, finalize) {
            const remaining = targetMs - (Date.now() - recordingStartTime);
            if (remaining <= 0) {
                finalize();
                return
            }
            setTimeout(finalize, remaining)
        }

        function resetToReadyState() {
            const currentScene = getCurrentScene();
            recordLayerBtn.disabled = !currentScene || currentScene.layers.length === 0;
            recordLayerBtn.textContent = 'Record Layer';
            recordLayerBtn.classList.add('record');
            sceneActionsContainer.classList.remove('hidden');
            stopActionsContainer.classList.add('hidden');
            commitLayerBtn.classList.add('hidden');
            commitLayerBtn.classList.remove('success');

            if (layerRecordingUrl) {
                URL.revokeObjectURL(layerRecordingUrl);
                layerRecordingUrl = null
            }

            recordedChunks = [];
            projectileVectorStart = null;
            projectileVectorEnd = null;
            gravityMenu.classList.add('hidden');
            gravityInstructions.textContent = '';
        }

        function updateProjectControlsState() {
            generateProjectBtn.disabled = scenes.length === 0;
        }

        function updateControlsState() {
            const hasScenes = scenes.length > 0;
            const currentScene = getCurrentScene();
            const hasAnyLayers = currentScene && currentScene.layers.some(l => !l.committed);
            const isPendingCommit = !!layerRecordingUrl;

            addSceneBtn.disabled = isRecording;
            deleteSceneBtn.disabled = !hasScenes || isRecording;
            recordLayerBtn.disabled = !hasAnyLayers || isRecording;
            
            textBtn.disabled = !hasScenes || isRecording || isPendingCommit;
            addNewTextLayerBtn.disabled = isRecording || isPendingCommit || !currentScene;

            const hasPreviewableContent = currentScene && (!!layerRecordingUrl || currentScene.committedLayerSrcs.length > 0);
            
            previewSceneBtn.disabled = !hasPreviewableContent || isRecording;
            updateProjectControlsState();
            renderLayerPalette();
            renderStackedLayersPalette();
            renderTextLayerPalette();
        }

        async function handleBackgroundUpload(file, mode, isFromLayerCommit = false, fromLibrary = false) {
            if (!file) return;

            if (file instanceof File && !fromLibrary && !isFromLayerCommit) {
                try {
                    const hash = await calculateFileHash(file);
                    const existing = await getAssetByHash(hash);
                    if (!existing) {
                        const newId = await saveAssetToDB(file, hash, 'background');
                        const newBgAsset = {
                            id: newId,
                            file: file,
                            hash: hash,
                            name: file.name,
                            type: 'background',
                            src: URL.createObjectURL(file)
                        };
                        projectLibraryBackgrounds.unshift(newBgAsset);
                        toast('Background saved to library.', 2000);
                        updateProjectLibraryDisplay();
                    }
                } catch (error) {
                    console.error("Error saving background to DB:", error);
                    toast('Could not save background to library.', 3000);
                }
            }


            const fileURL = (file instanceof Blob) ? URL.createObjectURL(file) : file;
            
            const handleNewScene = (element, type, thumb, durMs) => {
                let sceneToUpdate;
                if (isFromLayerCommit) {
                    sceneToUpdate = getCurrentScene();
                    if (sceneToUpdate) {
                        sceneToUpdate.backgroundElement = element;
                        sceneToUpdate.backgroundType = type;
                        sceneToUpdate.thumbnail = thumb;
                        sceneToUpdate.backgroundHistory.push(element);
                        const newDur = durMs ?? getMediaDurationMs(element, type);
                        ensureSceneDurationMs(sceneToUpdate, newDur);
                        toast('Layer committed! Add another asset to continue layering.', 4000)
                    }
                } else {
                    if (scenes.length > 0 && activeSceneId !== null && mode !== 'initial') {
                        sceneToUpdate = getCurrentScene();
                        sceneToUpdate.backgroundElement = element;
                        sceneToUpdate.backgroundType = type;
                        sceneToUpdate.thumbnail = thumb;
                    } else {
                        const initialDur = durMs ?? getMediaDurationMs(element, type);
                        sceneToUpdate = {
                            id: Date.now(),
                            backgroundElement: element,
                            backgroundType: type,
                            thumbnail: thumb,
                            layers: [],
                            originalBackgroundElement: element,
                            originalBackgroundType: type,
                            originalThumbnail: thumb,
                            committedLayerSrcs: [],
                            backgroundHistory: [element],
                            bgBrightness: 1,
                            bgSaturation: 1,
                            audioElement: null,
                            audioName: null,
                            durationMs: 0,
                            audioDurationMs: 0,
                            audioStartTime: 0
                        };
                        scenes.push(sceneToUpdate);
                        ensureSceneDurationMs(sceneToUpdate, initialDur);
                        if (mode === 'initial') {
                            canvasPlaceholder.classList.add('hidden');
                            toast('Background set! Add an asset to start.', 3000)
                        }
                    }
                }
                requestAnimationFrame(() => {
                    switchScene(sceneToUpdate.id);
                    updateControlsState();
                })
            };
            
            if (file.type.startsWith('image/')) {
                const img = new Image();
                img.onload = () => handleNewScene(img, 'image', img.src, 3000);
                img.onerror = () => toast('Could not load background image.');
                img.src = fileURL
            } else if (file.type.startsWith('video/')) {
                const video = document.createElement('video');
                video.loop = !isFromLayerCommit;
                video.autoplay = false;
                video.muted = true;
                video.playsinline = true;
                let durMs = 0;
                
                const onLoaded = () => {
                    durMs = getMediaDurationMs(video, 'video');
                    video.addEventListener('seeked', onSeeked, {once: true});
                    video.currentTime = 0.1;
                };

                const onSeeked = () => {
                    const thumbCanvas = document.createElement('canvas');
                    thumbCanvas.width = video.videoWidth;
                    thumbCanvas.height = video.videoHeight;
                    thumbCanvas.getContext('2d').drawImage(video, 0, 0);
                    handleNewScene(video, 'video', thumbCanvas.toDataURL('image/jpeg'), durMs);
                    video.currentTime = 0;
                    video.muted = false;
                };

                video.addEventListener('loadedmetadata', onLoaded, {once: true});
                video.onerror = () => toast('Could not load background video.');
                video.src = fileURL
            } else {
                toast('Unsupported file type. Please use an image or video.')
            }
        }

        function renderSceneTray() {
            sceneTray.innerHTML = '';
            scenes.forEach((scene, index) => {
                const thumb = document.createElement('div');
                thumb.className = 'scene-thumb';
                thumb.style.backgroundImage = `url(${scene.thumbnail})`;
                thumb.classList.toggle('active', scene.id === activeSceneId);
                thumb.innerHTML = `<span>${index + 1}</span>`;
                if (scenes.length > 0) {
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'scene-delete-btn';
                    deleteBtn.innerHTML = 'x';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteScene(scene.id)
                    };
                    thumb.appendChild(deleteBtn)
                }
                thumb.onclick = () => {
                    if (scene.id !== activeSceneId && !isRecording) switchScene(scene.id)
                };
                sceneTray.appendChild(thumb)
            })
        }

        function resizeCanvas() {
            const currentScene = getCurrentScene();
            if (!currentScene) return;
            const panelWidth = canvasPanel.clientWidth;
            const panelHeight = canvasPanel.clientHeight;
            if (panelWidth === 0 || panelHeight === 0) return;
            const canvasAspectRatio = movieCanvas.width / movieCanvas.height;
            let displayWidth, displayHeight;
            if (panelWidth / panelHeight > canvasAspectRatio) {
                displayHeight = panelHeight;
                displayWidth = displayHeight * canvasAspectRatio
            } else {
                displayWidth = panelWidth;
                displayHeight = displayWidth / canvasAspectRatio
            }

            [movieCanvas, controlsOverlayCanvas].forEach(c => {
                c.style.width = `${displayWidth}px`;
                c.style.height = `${displayHeight}px`;
            });

            pasteboardOverlayCanvas.width = movieCanvas.width + PASTEBOARD_MARGIN * 2;
            pasteboardOverlayCanvas.height = movieCanvas.height + PASTEBOARD_MARGIN * 2;
            
            const scaleFactor = displayWidth / movieCanvas.width;
            pasteboardOverlayCanvas.style.width = `${pasteboardOverlayCanvas.width * scaleFactor}px`;
            pasteboardOverlayCanvas.style.height = `${pasteboardOverlayCanvas.height * scaleFactor}px`;
        }

        function switchScene(sceneId) {
            hidePostGenerationActions();
            stopAnimationLoop();

            const oldScene = getCurrentScene();
            if (oldScene) {
                oldScene.layers.forEach(layer => {
                    if (layer.type === 'video') {
                        layer.asset.pause();
                    }
                });
            }

            activeSceneId = sceneId;
            const currentScene = getCurrentScene();

            if (currentScene && !currentScene.dominantColor) {
                currentScene.dominantColor = getDominantColor(currentScene.backgroundElement);
            }
            updateCanvasPanelBackground(currentScene);
            
            if (!currentScene) return;

            currentScene.sceneFadeInStart = Date.now();

            currentScene.layers.forEach(layer => {
                if (layer.type === 'video') {
                    layer.asset.play().catch(() => {});
                }
            });

            activeMovieLayerId = null;
            projectileVectorStart = null;
            projectileVectorEnd = null;
            gravityMenu.classList.add('hidden');

            const bg = currentScene.backgroundElement;
            const w = bg.naturalWidth || bg.videoWidth;
            const h = bg.naturalHeight || bg.videoHeight;
            let aspectRatio = w / h;
            if (!isFinite(aspectRatio) || aspectRatio === 0) { aspectRatio = 16 / 9 }
            
            const qualityWidth = masterWidth;
            movieCanvas.width = controlsOverlayCanvas.width = qualityWidth;
            movieCanvas.height = controlsOverlayCanvas.height = qualityWidth / aspectRatio;
            masterHeight = movieCanvas.height;

            resizeCanvas();
            renderSceneTray();
            renderLayerPalette();
            renderStackedLayersPalette();
            renderTextLayerPalette();
            resetToReadyState();
            updateControlsState();
            updateEditPanelsUI();
            updateAudioUI();
            startAnimationLoop()
        }

        function deleteScene(sceneIdToDelete) {
            if (scenes.length === 0) return;
            const sceneIndex = scenes.findIndex(s => s.id === sceneIdToDelete);
            if (scenes.length === 1) {
                clearProject();
                return
            }
            scenes.splice(sceneIndex, 1);
            if (activeSceneId === sceneIdToDelete) {
                const newActiveIndex = Math.max(0, sceneIndex - 1);
                switchScene(scenes[newActiveIndex].id)
            } else {
                renderSceneTray()
            }
            updateControlsState()
        }

        function openAssetLibrary() {
            assetLibraryOverlay.classList.add('visible')
        }

        function closeAssetLibrary() {
            assetLibraryOverlay.classList.remove('visible')
        }

        function updateLayerInstructions() {
            const currentScene = getCurrentScene();
            layerInstructions.classList.remove('placeholder-text');
            if (!currentScene) {
                layerInstructions.textContent = "Create a scene to begin.";
                layerInstructions.classList.add('placeholder-text');
                return
            }
            const hasActiveVisualLayers = currentScene.layers.some(l => l.type !== 'text' && !l.committed);
            const hasUncommittedText = currentScene.layers.some(l => l.type === 'text' && !l.committed);
            const hasCommittedLayers = currentScene.committedLayerSrcs.length > 0;
            
            if (hasActiveVisualLayers || hasUncommittedText) {
                layerInstructions.textContent = "Click 'Record Layer' to animate the asset(s) in the stack."
            } else if (hasCommittedLayers) {
                layerInstructions.textContent = "Add another asset to continue layering on this scene."
            } else {
                layerInstructions.textContent = "Add an asset from the library to begin."
            }
        }

        function renderTextLayerPalette() {
            textLayerPalette.innerHTML = '';
            const currentScene = getCurrentScene();
            if (!currentScene) return;

            const textLayers = currentScene.layers.filter(l => l.type === 'text');

            textLayers.forEach(layer => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb text-thumb';
                thumb.classList.toggle('active', layer.id === activeMovieLayerId && !layer.committed);
                thumb.dataset.layerId = layer.id;

                if (layer.committed) {
                    thumb.classList.add('locked');
                    thumb.title = "This text is committed to the scene.";
                } else {
                    thumb.title = "Click to select";
                }

                let thumbContent = `<span>${layer.text.split('\n')[0] || "Empty"}</span>`;
                
                if (!layer.committed) {
                    thumb.innerHTML = `${thumbContent}<div class="layer-controls"><div class="layer-btn delete" title="Delete Layer">x</div></div>`;
                } else {
                    thumb.innerHTML = thumbContent;
                }

                thumb.addEventListener('click', (e) => {
                    if (e.target.classList.contains('layer-btn') || layer.committed) return;
                    
                    if (activeMovieLayerId !== layer.id) {
                        activeMovieLayerId = layer.id;
                        renderLayerPalette();
                        renderStackedLayersPalette();
                        renderTextLayerPalette();
                        updateEditPanelsUI();
                    }
                });

                if (!layer.committed) {
                    thumb.querySelector('.delete').onclick = (e) => {
                        e.stopPropagation();
                        deleteMovieLayer(layer.id);
                    };
                }
                
                textLayerPalette.appendChild(thumb);
            });
        }
        
        function addDragAndDropHandlers(thumb) {
            thumb.setAttribute('draggable', 'true');

            thumb.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', thumb.dataset.layerId);
                setTimeout(() => {
                    thumb.classList.add('dragging');
                }, 0);
            });

            thumb.addEventListener('dragend', () => {
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                thumb.classList.remove('dragging');
            });

            thumb.addEventListener('dragover', (e) => {
                e.preventDefault();
                const dragging = document.querySelector('.dragging');
                if (dragging && dragging !== thumb) {
                    thumb.classList.add('drag-over');
                }
            });

            thumb.addEventListener('dragleave', (e) => {
                e.preventDefault();
                thumb.classList.remove('drag-over');
            });

            thumb.addEventListener('drop', (e) => {
                e.preventDefault();
                thumb.classList.remove('drag-over');
                const draggedId = e.dataTransfer.getData('text/plain');
                const droppedOnId = thumb.dataset.layerId;

                if (draggedId === droppedOnId) return;

                const currentScene = getCurrentScene();
                if (!currentScene) return;

                const activeVisualLayers = currentScene.layers.filter(l => l.type !== 'text' && !l.committed);
                const otherLayers = currentScene.layers.filter(l => l.type === 'text' || l.committed);

                const draggedIndex = activeVisualLayers.findIndex(l => l.id.toString() === draggedId);
                const droppedOnIndex = activeVisualLayers.findIndex(l => l.id.toString() === droppedOnId);

                if (draggedIndex > -1 && droppedOnIndex > -1) {
                    const [draggedItem] = activeVisualLayers.splice(draggedIndex, 1);
                    activeVisualLayers.splice(droppedOnIndex, 0, draggedItem);
                    currentScene.layers = [...activeVisualLayers, ...otherLayers];

                    renderLayerPalette();
                    renderStackedLayersPalette();
                }
            });
        }
                
        function renderStackedLayersPalette() {
            const stackPalette = document.getElementById('mg-stacked-layers-palette');
            const stackFieldset = document.getElementById('stack-assets-fieldset');
            stackPalette.innerHTML = ''; 

            const currentScene = getCurrentScene();
            if (!currentScene) {
                stackFieldset.classList.add('hidden');
                return;
            }

            const activeVisualLayers = currentScene.layers.filter(l => l.type !== 'text' && !l.committed);
            const isPendingCommit = !!layerRecordingUrl;

            if (activeVisualLayers.length === 0) {
                stackFieldset.classList.add('hidden');
                return;
            } 
            
            stackFieldset.classList.remove('hidden');
            
            activeVisualLayers.forEach(activeLayer => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb';
                thumb.classList.toggle('active', activeLayer.id === activeMovieLayerId);
                thumb.dataset.layerId = activeLayer.id;
                
                let thumbContent = activeLayer.type === 'video' ? `<video src="${activeLayer.src}" muted loop autoplay playsinline></video>` : `<img src="${activeLayer.src}">`;
                
                addDragAndDropHandlers(thumb);
                thumb.title = isRecording ? "Drag to reorder during recording" : "Click to select or drag to reorder";

                if (isPendingCommit || isRecording) {
                    thumb.classList.add('locked');
                    thumb.innerHTML = thumbContent;
                } else {
                    thumb.innerHTML = `${thumbContent}<div class="layer-controls"><div class="layer-btn delete" title="Delete Layer">x</div></div>`;
                    thumb.addEventListener('click', (e) => {
                        if (e.target.classList.contains('layer-btn')) return;
                        if (activeMovieLayerId !== activeLayer.id) {
                            activeMovieLayerId = activeLayer.id;
                            renderLayerPalette();
                            renderStackedLayersPalette();
                            renderTextLayerPalette();
                        }
                    });
                    thumb.querySelector('.delete').onclick = (e) => {
                        e.stopPropagation();
                        if (isPendingCommit) {
                            resetTake();
                            toast('Take cancelled.', 2000);
                        } else {
                            deleteMovieLayer(activeLayer.id);
                        }
                    };
                }

                stackPalette.appendChild(thumb);
            });

            const emptySlot = document.createElement('button');
            emptySlot.className = 'palette-slot empty';
            emptySlot.innerHTML = '+';
            emptySlot.title = "Add a new image or video asset";
            emptySlot.onclick = openAssetLibrary;
            
            if (isRecording || isPendingCommit) {
                emptySlot.disabled = true;
                emptySlot.title = "Commit or re-record to add a new asset.";
            }
            stackPalette.appendChild(emptySlot);
        }
                
        function renderLayerPalette() {
            assetPalette.innerHTML = '';
            updateLayerInstructions();
            const currentScene = getCurrentScene();

            if (!currentScene) {
                const emptySlot = document.createElement('button');
                emptySlot.className = 'palette-slot empty';
                emptySlot.innerHTML = '+';
                emptySlot.title = "Create a scene first";
                emptySlot.disabled = true;
                assetPalette.appendChild(emptySlot);
                return;
            }

            currentScene.committedLayerSrcs.forEach((srcOrArray, index) => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb locked';
                
                if (Array.isArray(srcOrArray)) {
                    const collageContainer = document.createElement('div');
                    collageContainer.className = 'committed-collage-thumb';
                    srcOrArray.forEach(src => {
                        if (src.startsWith('data:image')) return;
                        const img = document.createElement('img');
                        img.src = src;
                        collageContainer.appendChild(img);
                    });
                    thumb.appendChild(collageContainer);
                } else {
                    if (!srcOrArray.startsWith('data:image')) {
                        let imgContent = `<img src="${srcOrArray}">`;
                        thumb.innerHTML = imgContent;
                    }
                }

                const isLastCommittedLayer = (index === currentScene.committedLayerSrcs.length - 1);
                if (isLastCommittedLayer && !isRecording) {
                    thumb.title = "Most recent commit. Click X to revert.";
                    const controls = document.createElement('div');
                    controls.className = 'layer-controls';
                    controls.innerHTML = `<div class="layer-btn delete" title="Revert this commit">x</div>`;
                    controls.querySelector('.delete').onclick = (e) => {
                        e.stopPropagation();
                        openConfirmationModal("Are you sure you want to revert your last commit?", () => {
                            deleteCommittedLayer(index);
                            closeConfirmationModal();
                        });
                    };
                    thumb.appendChild(controls);
                } else {
                    thumb.title = "This layer is locked.";
                }
                assetPalette.appendChild(thumb);
            });

            const activeVisualLayers = currentScene.layers.filter(l => l.type !== 'text' && !l.committed);
            
            if (activeVisualLayers.length > 0) {
                const primaryAsset = activeVisualLayers[0];
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb locked';
                thumb.title = "Top Layer (manage in Multi-asset Layering below)";
                thumb.innerHTML = primaryAsset.type === 'video' 
                    ? `<video src="${primaryAsset.src}" muted loop autoplay playsinline></video>` 
                    : `<img src="${primaryAsset.src}">`;
                
                assetPalette.appendChild(thumb);
            }
            
            const emptySlot = document.createElement('button');
            emptySlot.className = 'palette-slot empty';
            emptySlot.innerHTML = '+';
            emptySlot.title = "Add a new image or video asset";
            emptySlot.onclick = openAssetLibrary;
            
            emptySlot.disabled = activeVisualLayers.length > 0 || isRecording || !!layerRecordingUrl;
            if (emptySlot.disabled) {
                emptySlot.title = activeVisualLayers.length > 0 ? "Add new assets in the 'Multi-asset Layering' panel" : "Cannot add assets now";
            }

            assetPalette.appendChild(emptySlot);
        }

        function deleteCommittedLayer(indexToDelete) {
            const scene = getCurrentScene();
            if (!scene) return;
            const sources = scene.committedLayerSrcs[indexToDelete];
            if (Array.isArray(sources)) {
                sources.forEach(src => {
                    if (src.startsWith('blob:')) URL.revokeObjectURL(src);
                });
            } else if (typeof sources === 'string' && sources.startsWith('blob:')) {
                URL.revokeObjectURL(sources);
            }
            
            const backgroundToRestore = scene.backgroundHistory[indexToDelete];
            scene.backgroundElement = backgroundToRestore;
            scene.backgroundType = (backgroundToRestore.tagName === 'VIDEO') ? 'video' : 'image';
            scene.backgroundHistory.splice(indexToDelete + 1);
            scene.committedLayerSrcs.splice(indexToDelete);

            scene.layers = scene.layers.filter(l => l.type !== 'text');


            ensureSceneDurationMs(scene, getMediaDurationMs(scene.backgroundElement, scene.backgroundType));
            let newThumbnail;
            if (backgroundToRestore.tagName === 'VIDEO') {
                const tempVideo = backgroundToRestore.cloneNode(true);
                tempVideo.muted = true;
                tempVideo.autoplay = false;
                tempVideo.playsinline = true;
                const captureThumbnail = () => {
                    const thumbCanvas = document.createElement('canvas');
                    thumbCanvas.width = tempVideo.videoWidth;
                    thumbCanvas.height = tempVideo.videoHeight;
                    thumbCanvas.getContext('2d').drawImage(tempVideo, 0, 0);
                    newThumbnail = thumbCanvas.toDataURL('image/jpeg');
                    tempVideo.removeEventListener('seeked', captureThumbnail);
                    tempVideo.pause();
                    scene.thumbnail = newThumbnail;
                    switchScene(scene.id);
                    toast('Layer reverted.', 2000)
                };
                tempVideo.addEventListener('seeked', captureThumbnail);
                tempVideo.currentTime = 0.1;
                tempVideo.load()
            } else {
                if (backgroundToRestore.tagName === 'IMG') {
                    newThumbnail = backgroundToRestore.src
                } else {
                    newThumbnail = backgroundToRestore.src || backgroundToRestore.toDataURL?.('image/png') || ''
                }
                scene.thumbnail = newThumbnail;
                switchScene(scene.id);
                toast('Layer reverted.', 2000)
            }
        }

        function updateAssetVisualsUI() {
            const activeLayer = getActiveLayer();
            if (activeLayer && (activeLayer.type === 'image' || activeLayer.type === 'video')) {
                assetVisualsControls.classList.remove('disabled');
                assetOpacitySlider.value = activeLayer.targetOpacity ?? activeLayer.opacity;
                assetBrightnessSlider.value = activeLayer.brightness;
                assetSaturationSlider.value = activeLayer.saturation;

                shadowEnable.checked = activeLayer.shadow.enabled;
                shadowControls.classList.toggle('disabled', !shadowEnable.checked);
                shadowColor.value = activeLayer.shadow.color;
                shadowBlur.value = activeLayer.shadow.blur;
                shadowOffsetX.value = activeLayer.shadow.offsetX;
                shadowOffsetY.value = activeLayer.shadow.offsetY;

                borderEnable.checked = activeLayer.border.enabled;
                borderControls.classList.toggle('disabled', !borderEnable.checked);
                borderColor.value = activeLayer.border.color;
                borderWidth.value = activeLayer.border.width;

            } else {
                assetVisualsControls.classList.add('disabled');
                assetOpacitySlider.value = 1;
                assetBrightnessSlider.value = 1;
                assetSaturationSlider.value = 1;
            }
        }

        function updateTextVisualsUI() {
            const activeLayer = getActiveLayer();
            if (activeLayer && activeLayer.type === 'text') {
                textVisualsControls.classList.remove('disabled');
                textContentInput.value = activeLayer.text;
                
                textFontSelect.value = activeLayer.font;
                const selectedOption = Array.from(textFontSelect.options).find(opt => opt.value === activeLayer.font);
                document.getElementById('custom-font-select-label').textContent = selectedOption ? selectedOption.textContent : 'Select Font';

                textSizeSlider.value = activeLayer.fontSize;
                textColorInput.value = activeLayer.color;
                textStrokeColorInput.value = activeLayer.strokeColor;
                textStrokeWidthSlider.value = activeLayer.strokeWidth;
                textOpacitySlider.value = activeLayer.targetOpacity ?? activeLayer.opacity;
                textBrightnessSlider.value = activeLayer.brightness;
            } else {
                textVisualsControls.classList.add('disabled');
                textContentInput.value = "New Text";
                textFontSelect.value = "'VT323', monospace";
                document.getElementById('custom-font-select-label').textContent = 'VT323';
                textSizeSlider.value = 60;
                textColorInput.value = "#FFFFFF";
                textStrokeColorInput.value = '#000000';
                textStrokeWidthSlider.value = 0;
                textOpacitySlider.value = 1;
                textBrightnessSlider.value = 1;
            }
        }

        function updateBackgroundVisualsUI() {
            const currentScene = getCurrentScene();
            bgBrightnessSlider.value = currentScene ? currentScene.bgBrightness : 1;
            bgSaturationSlider.value = currentScene ? currentScene.bgSaturation : 1;
        }

        function updateEditPanelsUI() {
            updateAssetVisualsUI();
            updateTextVisualsUI();
            updateBackgroundVisualsUI();
        }

        function updateAudioUI() {
            const currentScene = getCurrentScene();
            if (!currentScene) {
                audioControls.classList.add('disabled');
                audioFileName.textContent = "No active scene.";
                uploadAudioLabel.classList.remove('disabled');
                removeAudioBtn.disabled = true;
            } else {
                audioControls.classList.remove('disabled');
                if (currentScene.audioName) {
                    audioFileName.textContent = currentScene.audioName;
                    uploadAudioLabel.classList.add('disabled');
                    removeAudioBtn.disabled = false;
                } else {
                    audioFileName.textContent = "No audio added.";
                    uploadAudioLabel.classList.remove('disabled');
                    removeAudioBtn.disabled = true;
                }
            }
        }

        function addTextLayer() {
            const currentScene = getCurrentScene();
            if (!currentScene) {
                toast('Add a background first.', 2000);
                return
            }
            
            const newTextLayer = {
                id: (Date.now() + Math.random()).toString(),
                type: 'text',
                text: 'New Text',
                font: "'VT323', monospace",
                fontSize: 150,
                color: '#FFFFFF',
                strokeColor: '#000000',
                strokeWidth: 0,
                x: movieCanvas.width / 2,
                y: movieCanvas.height / 2,
                rot: 0,
                flipX: false,
                targetOpacity: 1,
                opacity: 0,
                fadeInStartTime: Date.now(),
                brightness: 1,
                saturation: 1,
                shadow: { enabled: false, color: '#000000', blur: 10, offsetX: 10, offsetY: 10 },
                border: { enabled: false, color: '#FFFFFF', width: 4 },
                width: 0,
                height: 0,
                isProjectileActive: false,
                projectileVectorX: 0,
                projectileVectorY: 0,
                projectileStartX: 0,
                projectileStartY: 0,
                projectileTimestamp: 0,
                projectileInitialRotation: 0,
                projectileInitialFlipX: false,
                gravityValue: 0, 
                projectileRotationRate: 0,
                committed: false
            };
            currentScene.layers.push(newTextLayer);
            activeMovieLayerId = newTextLayer.id;
            renderLayerPalette();
            renderStackedLayersPalette();
            renderTextLayerPalette();
            updateControlsState();
            updateEditPanelsUI();
            if (getCurrentScene()) getCurrentScene().layerStartingStates = null;
            toast('Text layer added!', 2000);
            textContentInput.focus();
            textContentInput.select();
        }

        function deleteMovieLayer(layerId) {
            hidePostGenerationActions();
            const currentScene = getCurrentScene();
            if (!currentScene) return;
            const layer = currentScene.layers.find(l => l.id === layerId);
            if (!layer) return;

            const isTextLayer = layer.type === 'text';

            if (layer.type === 'video') {
                layer.asset.pause();
            }
            currentScene.layers = currentScene.layers.filter(l => l.id !== layerId);

            if (activeMovieLayerId === layerId) {
                activeMovieLayerId = null;
                projectileVectorStart = null;
                projectileVectorEnd = null;
                gravityMenu.classList.add('hidden');
            }

            renderLayerPalette();
            renderStackedLayersPalette();
            if (isTextLayer) {
                renderTextLayerPalette();
            }
            updateControlsState();
            updateEditPanelsUI();
            if (getCurrentScene()) getCurrentScene().layerStartingStates = null;
        }
        
        function getTextBlockMetrics(ctx, text, font, fontSize) {
            ctx.save();
            ctx.font = `${fontSize}px ${font}`;
            const lines = text.split('\n');
            const lineHeight = fontSize * 1.2;
            let maxWidth = 0;
            lines.forEach(line => {
                const lineWidth = ctx.measureText(line).width;
                if (lineWidth > maxWidth) {
                    maxWidth = lineWidth;
                }
            });
            const totalHeight = lines.length * lineHeight;
            ctx.restore();
            return { lines, lineHeight, maxWidth, totalHeight };
        }

        function drawMovieFrame() {
            const currentScene = getCurrentScene();
            if (!currentScene || !currentScene.backgroundElement) {
                movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
                return;
            }

            const { backgroundElement, layers: movieLayers, bgBrightness, bgSaturation } = currentScene;
            movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
            movieCtx.save();
            movieCtx.filter = `brightness(${bgBrightness}) saturate(${bgSaturation})`;

            const SCENE_FADE_DURATION = 500;
            if (currentScene.sceneFadeInStart) {
                const elapsed = Date.now() - currentScene.sceneFadeInStart;
                const alpha = Math.min(1, elapsed / SCENE_FADE_DURATION);
                movieCtx.globalAlpha = alpha;
                if (alpha >= 1) {
                    delete currentScene.sceneFadeInStart;
                }
            }
            
            movieCtx.drawImage(backgroundElement, 0, 0, movieCanvas.width, movieCanvas.height);
            movieCtx.restore();

            for (let i = movieLayers.length - 1; i >= 0; i--) {
                const l = movieLayers[i];
                
                if (l.committed) continue;

                if (l.type === 'video' && l.asset.duration) {
                    if (l.asset.duration - l.asset.currentTime < 0.1) {
                        l.asset.currentTime = 0;
                        l.asset.play();
                    }
                }
                
                movieCtx.save();

                const ASSET_FADE_DURATION = 400;
                if (l.fadeInStartTime) {
                    const elapsed = Date.now() - l.fadeInStartTime;
                    const targetOpacity = l.targetOpacity || 1;
                    const calculatedOpacity = Math.min(targetOpacity, (elapsed / ASSET_FADE_DURATION) * targetOpacity);
                    l.opacity = calculatedOpacity;
                    
                    if (l.opacity >= targetOpacity) {
                        delete l.fadeInStartTime;
                        delete l.targetOpacity;
                        l.opacity = targetOpacity;
                    }
                }

                if (isRecording && l.isProjectileActive && l.projectileTimestamp > 0) {
                    const elapsedTimeSeconds = (Date.now() - l.projectileTimestamp) / 1000;
                    l.x = l.projectileStartX + l.projectileVectorX * elapsedTimeSeconds;
                    l.y = l.projectileStartY + l.projectileVectorY * elapsedTimeSeconds + 0.5 * l.gravityValue * elapsedTimeSeconds * elapsedTimeSeconds;
                    l.rot = l.projectileInitialRotation + (l.projectileRotationRate * elapsedTimeSeconds);
                    l.flipX = l.projectileInitialFlipX;
                }
                
                const filters = [];
                if (l.border && l.border.enabled && l.border.width > 0) {
                    const w = l.border.width;
                    const c = l.border.color;
                    filters.push(`drop-shadow(${w}px 0px 0 ${c})`);
                    filters.push(`drop-shadow(-${w}px 0px 0 ${c})`);
                    filters.push(`drop-shadow(0px ${w}px 0 ${c})`);
                    filters.push(`drop-shadow(0px -${w}px 0 ${c})`);
                }
                if (l.shadow && l.shadow.enabled) {
                    filters.push(`drop-shadow(${l.shadow.offsetX}px ${l.shadow.offsetY}px ${l.shadow.blur}px ${l.shadow.color})`);
                }
                filters.push(`brightness(${l.brightness})`);
                filters.push(`saturate(${l.saturation})`);
                movieCtx.filter = filters.join(' ');

                movieCtx.globalAlpha = l.opacity;
                movieCtx.translate(l.x, l.y);
                movieCtx.rotate(l.rot * Math.PI / 180);
                if (l.flipX) {
                    movieCtx.scale(-1, 1)
                }
                if (l.type === 'image' || l.type === 'video') {
                    const elementToDraw = l.asset;
                    const isReady = (l.type === 'image' && l.asset.complete) || (l.type === 'video' && l.asset.readyState > 1);
                    if (elementToDraw && isReady) {
                         const assetWidth = l.type === 'image' ? l.asset.naturalWidth : l.asset.videoWidth;
                         const assetHeight = l.type === 'image' ? l.asset.naturalHeight : l.asset.videoHeight;
                         if (assetWidth === 0) {
                            movieCtx.restore();
                            continue;
                         }
                        const dWidth = l.size;
                        const dHeight = l.size * (assetHeight / assetWidth);
                        movieCtx.drawImage(elementToDraw, -dWidth / 2, -dHeight / 2, dWidth, dHeight)
                    }
                } else if (l.type === 'text') {
                    movieCtx.font = `${l.fontSize}px ${l.font}`;
                    movieCtx.fillStyle = l.color;
                    movieCtx.textAlign = 'center';
                    movieCtx.textBaseline = 'middle';
                    if (l.strokeWidth > 0) {
                        movieCtx.strokeStyle = l.strokeColor;
                        movieCtx.lineWidth = l.strokeWidth;
                    }
                    const metrics = getTextBlockMetrics(movieCtx, l.text, l.font, l.fontSize);
                    l.width = metrics.maxWidth;
                    l.height = metrics.totalHeight;
                    const startY = -metrics.totalHeight / 2 + metrics.lineHeight / 2 - (l.fontSize * 0.1);
                    metrics.lines.forEach((line, index) => {
                        if (l.strokeWidth > 0) {
                            movieCtx.strokeText(line, 0, startY + (index * metrics.lineHeight));
                        }
                        movieCtx.fillText(line, 0, startY + (index * metrics.lineHeight));
                    });
                }
                movieCtx.restore();
            }
        }

        function drawRecordingFrame() {
            const currentScene = getCurrentScene();
            if (!currentScene || !currentScene.backgroundElement) return;

            const { backgroundElement, layers: movieLayers, bgBrightness, bgSaturation } = currentScene;

            recordingCanvas.width = masterWidth;
            recordingCanvas.height = masterHeight;

            recordingCtx.clearRect(0, 0, recordingCanvas.width, recordingCanvas.height);
            recordingCtx.save();
            recordingCtx.filter = `brightness(${bgBrightness}) saturate(${bgSaturation})`;
            recordingCtx.drawImage(backgroundElement, 0, 0, recordingCanvas.width, recordingCanvas.height);
            recordingCtx.restore();

            const previewCanvasWidth = movieCanvas.width;
            const previewCanvasHeight = movieCanvas.height;

            for (let i = movieLayers.length - 1; i >= 0; i--) {
                const l = movieLayers[i];
                if (l.committed) continue;
                
                recordingCtx.save();
                recordingCtx.globalAlpha = l.opacity;
                
                const filters = [];
                if (l.border && l.border.enabled && l.border.width > 0) {
                    const w = l.border.width;
                    const c = l.border.color;
                    filters.push(`drop-shadow(${w}px 0px 0 ${c})`);
                    filters.push(`drop-shadow(-${w}px 0px 0 ${c})`);
                    filters.push(`drop-shadow(0px ${w}px 0 ${c})`);
                    filters.push(`drop-shadow(0px -${w}px 0 ${c})`);
                }
                if (l.shadow && l.shadow.enabled) {
                    filters.push(`drop-shadow(${l.shadow.offsetX}px ${l.shadow.offsetY}px ${l.shadow.blur}px ${l.shadow.color})`);
                }
                filters.push(`brightness(${l.brightness})`);
                filters.push(`saturate(${l.saturation})`);
                recordingCtx.filter = filters.join(' ');

                const scaleX = recordingCanvas.width / previewCanvasWidth;
                const scaleY = recordingCanvas.height / previewCanvasHeight;
                const finalX = l.x * scaleX;
                const finalY = l.y * scaleY;
                recordingCtx.translate(finalX, finalY);
                recordingCtx.rotate(l.rot * Math.PI / 180);
                if (l.flipX) {
                    recordingCtx.scale(-1, 1)
                }
                if (l.type === 'image' || l.type === 'video') {
                    const isReady = (l.type === 'image' && l.asset.complete) || (l.type === 'video' && l.asset.readyState > 1);
                    if (l.asset && isReady) {
                        const assetWidth = l.type === 'image' ? l.asset.naturalWidth : l.asset.videoWidth;
                        const assetHeight = l.type === 'image' ? l.asset.naturalHeight : l.asset.videoHeight;
                        if (assetWidth === 0) {
                            recordingCtx.restore();
                            continue;
                        }
                        const scaledSize = l.size * scaleX;
                        const dWidth = scaledSize;
                        const dHeight = scaledSize * (assetHeight / assetWidth);
                        recordingCtx.drawImage(l.asset, -dWidth / 2, -dHeight / 2, dWidth, dHeight)
                    }
                } else if (l.type === 'text') {
                    const scaledFontSize = l.fontSize * scaleY;
                    recordingCtx.font = `${scaledFontSize}px ${l.font}`;
                    recordingCtx.fillStyle = l.color;
                    recordingCtx.textAlign = 'center';
                    recordingCtx.textBaseline = 'middle';
                    if (l.strokeWidth > 0) {
                        recordingCtx.strokeStyle = l.strokeColor;
                        recordingCtx.lineWidth = l.strokeWidth * scaleY;
                    }
                    const metrics = getTextBlockMetrics(recordingCtx, l.text, l.font, scaledFontSize);
                    const startY = -metrics.totalHeight / 2 + metrics.lineHeight / 2 - (scaledFontSize * 0.1);

                    metrics.lines.forEach((line, index) => {
                        if (l.strokeWidth > 0) {
                            recordingCtx.strokeText(line, 0, startY + (index * metrics.lineHeight));
                        }
                        recordingCtx.fillText(line, 0, startY + (index * metrics.lineHeight));
                    });
                }
                recordingCtx.restore();
            }
        }

        function animationLoop(timestamp) {
            if (isRecording) {
                const elapsed = timestamp - lastRecordingFrameTime;
                if (elapsed >= recordingFrameInterval) {
                    lastRecordingFrameTime = timestamp - (elapsed % recordingFrameInterval);
                    drawRecordingFrame();
                }
            }
            
            drawMovieFrame();
            drawControlsOverlay();

            animationFrameId = requestAnimationFrame(animationLoop);
        }

        function drawControlsOverlay() {
            const isPasteboard = isCanvasViewZoomedOut && canvasPanel.classList.contains('is-zoomed-out');
            const ctx = isPasteboard ? pasteboardCtx : controlsCtx;
            const canvas = isPasteboard ? pasteboardOverlayCanvas : controlsOverlayCanvas;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const activeLayer = getActiveLayer();
            if (!activeLayer || (activeLayer.type === 'text' && activeLayer.committed)) {
                return;
            }

            ctx.save();
            if (isPasteboard) {
                ctx.translate(PASTEBOARD_MARGIN, PASTEBOARD_MARGIN);
            }

            let dWidth, dHeight;

            if (activeLayer.type === 'image' || activeLayer.type === 'video') {
                const assetWidth = activeLayer.type === 'image' ? activeLayer.asset.naturalWidth : activeLayer.asset.videoWidth;
                const assetHeight = activeLayer.type === 'image' ? activeLayer.asset.naturalHeight : activeLayer.asset.videoHeight;
                if (assetWidth === 0) { ctx.restore(); return; }
                dWidth = activeLayer.size;
                dHeight = activeLayer.size * (assetHeight / assetWidth);
            } else if (activeLayer.type === 'text') {
                const metrics = getTextBlockMetrics(ctx, activeLayer.text, activeLayer.font, activeLayer.fontSize);
                dWidth = metrics.maxWidth;
                dHeight = metrics.totalHeight;
            } else {
                ctx.restore(); return;
            }

            const HANDLE_SIZE = 16;
            const ho = HANDLE_SIZE / 2;
            const ROTATION_HANDLE_OFFSET = 30;

            ctx.save();
            ctx.translate(activeLayer.x, activeLayer.y);
            ctx.rotate(activeLayer.rot * Math.PI / 180);

            if (!activeLayer.isProjectileActive) {
                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = 2;
            } else {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.lineWidth = 1;
            }
            ctx.strokeRect(-dWidth / 2, -dHeight / 2, dWidth, dHeight);

            if (!activeLayer.isProjectileActive) {
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(-dWidth / 2 - ho, -dHeight / 2 - ho, HANDLE_SIZE, HANDLE_SIZE);
                ctx.fillRect(dWidth / 2 - ho, -dHeight / 2 - ho, HANDLE_SIZE, HANDLE_SIZE);
                ctx.fillRect(-dWidth / 2 - ho, dHeight / 2 - ho, HANDLE_SIZE, HANDLE_SIZE);
                ctx.fillRect(dWidth / 2 - ho, dHeight / 2 - ho, HANDLE_SIZE, HANDLE_SIZE);

                const rotHandleY = -dHeight / 2 - ROTATION_HANDLE_OFFSET;
                ctx.beginPath();
                ctx.moveTo(0, -dHeight / 2);
                ctx.lineTo(0, rotHandleY);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, rotHandleY, HANDLE_SIZE / 2, 0, 2 * Math.PI);
                ctx.fill();
            }

            if (!isRecording) {
                const handlePos = getProjectileHandlePosition(activeLayer, dWidth, dHeight);
                const projectileHandleLocalX = handlePos.x;
                const projectileHandleLocalY = handlePos.y;

                ctx.fillStyle = activeLayer.isProjectileActive ? 'orange' : 'grey';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(projectileHandleLocalX, projectileHandleLocalY, PROJECTILE_HANDLE_SIZE / 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.moveTo(projectileHandleLocalX - 5, projectileHandleLocalY + 2);
                ctx.lineTo(projectileHandleLocalX + 5, projectileHandleLocalY - 2);
                ctx.moveTo(projectileHandleLocalX + 2, projectileHandleLocalY - 5);
                ctx.lineTo(projectileHandleLocalX + 5, projectileHandleLocalY - 2);
                ctx.lineTo(projectileHandleLocalX + 2, projectileHandleLocalY + 1);
                ctx.fill();
            }

            ctx.restore();

            if (!isRecording) {
                if (movieInteraction.active && movieInteraction.type === 'projectile-draw' && activeMovieLayerId === activeLayer.id) {
                    if (projectileVectorStart && projectileVectorEnd) {
                        ctx.save();
                        ctx.strokeStyle = '#00FF00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(projectileVectorStart.x, projectileVectorStart.y);
                        ctx.lineTo(projectileVectorEnd.x, projectileVectorEnd.y);
                        ctx.stroke();

                        const headlen = 10;
                        const angle = Math.atan2(projectileVectorEnd.y - projectileVectorStart.y, projectileVectorEnd.x - projectileVectorStart.x);
                        ctx.lineTo(projectileVectorEnd.x - headlen * Math.cos(angle - Math.PI / 6), projectileVectorEnd.y - headlen * Math.sin(angle - Math.PI / 6));
                        ctx.moveTo(projectileVectorEnd.x, projectileVectorEnd.y);
                        ctx.lineTo(projectileVectorEnd.x - headlen * Math.cos(angle + Math.PI / 6), projectileVectorEnd.y - headlen * Math.sin(angle + Math.PI / 6));
                        ctx.stroke();

                        const velX = (projectileVectorEnd.x - projectileVectorStart.x) * VELOCITY_MULTIPLIER;
                        const velY = (projectileVectorEnd.y - projectileVectorStart.y) * VELOCITY_MULTIPLIER;
                        ctx.fillStyle = 'white';
                        ctx.font = '16px VT323, monospace';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText(`Vx: ${velX.toFixed(2)}, Vy: ${velY.toFixed(2)}`, projectileVectorEnd.x + 10, projectileVectorEnd.y - 10);
                        ctx.restore();

                        if (activeLayer.gravityValue !== 0) {
                            drawGravityTrajectory(activeLayer, projectileVectorStart.x, projectileVectorStart.y, velX, velY, activeLayer.gravityValue, true);
                        }
                    }
                } else if (activeLayer.isProjectileActive && (activeLayer.projectileVectorX !== 0 || activeLayer.projectileVectorY !== 0)) {
                    ctx.save();
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(activeLayer.x, activeLayer.y);
                    const endX = activeLayer.x + activeLayer.projectileVectorX / VELOCITY_MULTIPLIER;
                    const endY = activeLayer.y + activeLayer.projectileVectorY / VELOCITY_MULTIPLIER;
                    ctx.lineTo(endX, endY);
                    ctx.stroke();

                    const headlen = 10;
                    const angle = Math.atan2(endY - activeLayer.y, endX - activeLayer.x);
                    ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), endY - headlen * Math.sin(angle - Math.PI / 6));
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), endY - headlen * Math.sin(angle + Math.PI / 6));
                    ctx.stroke();
                    ctx.restore();
                    ctx.setLineDash([]);

                    if (activeLayer.gravityValue !== 0) {
                        drawGravityTrajectory(activeLayer, activeLayer.x, activeLayer.y, activeLayer.projectileVectorX, activeLayer.projectileVectorY, activeLayer.gravityValue, false);
                    }
                }
            }
            
            ctx.restore();
        }

        function drawGravityTrajectory(layer, startX, startY, initialVelX, initialVelY, gravity, isLiveDrawing) {
            const isPasteboard = isCanvasViewZoomedOut && canvasPanel.classList.contains('is-zoomed-out');
            const ctx = isPasteboard ? pasteboardCtx : controlsCtx;
            
            ctx.save();
            ctx.strokeStyle = 'rgba(200,200,200,0.9)';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]); 
            ctx.beginPath();
            ctx.moveTo(startX, startY);

            const velocityMagnitude = Math.hypot(initialVelX, initialVelY);
            let simulatedTime = velocityMagnitude * TRAJECTORY_TIME_SCALING_FACTOR;
            simulatedTime = Math.min(simulatedTime, MAX_TRAJECTORY_TIME_SECONDS); 
            simulatedTime = Math.max(simulatedTime, 0.1);

            for (let i = 1; i <= GRAVITY_TRAJECTORY_STEPS; i++) {
                const t = (i / GRAVITY_TRAJECTORY_STEPS) * simulatedTime; 
                const currentX = startX + initialVelX * t;
                const currentY = startY + initialVelY * t + 0.5 * gravity * t * t;
                ctx.lineTo(currentX, currentY);

                if (currentX < -500 || currentX > movieCanvas.width + 500 || currentY < -500 || currentY > movieCanvas.height + 500) {
                    break;
                }
            }
            ctx.stroke();
            ctx.restore();
            ctx.setLineDash([]);
        }
        
        function formatTime(time) {
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function initWaveform(audioUrl) {
            if (wavesurfer) {
                wavesurfer.destroy();
            }

            const waveformContainer = document.getElementById('waveform');
            const waveformLoading = document.getElementById('waveform-loading');
            const audioPlaybackControls = document.getElementById('audio-playback-controls');
            const audioInstructions = document.getElementById('audio-instructions');
            const waveformTime = document.getElementById('waveform-time');

            waveformContainer.style.display = 'block';
            waveformLoading.style.display = 'block';
            audioPlaybackControls.style.display = 'none';
            audioInstructions.style.display = 'none';
            waveformTime.style.display = 'none';

            wavesurfer = WaveSurfer.create({
                container: '#waveform',
                waveColor: 'var(--mid)',
                progressColor: 'var(--action-color)',
                barWidth: 2,
                barRadius: 3,
                cursorWidth: 2,
                cursorColor: 'var(--danger-color)',
                height: 100,
                barGap: 3
            });

            wavesurfer.load(audioUrl);

            wavesurfer.on('ready', function () {
                waveformLoading.style.display = 'none';
                audioPlaybackControls.style.display = 'grid';
                audioInstructions.style.display = 'block';
                waveformTime.style.display = 'block';
                document.getElementById('play-pause-audio-btn').textContent = 'Play';
                waveformTime.textContent = `${formatTime(wavesurfer.getCurrentTime())} / ${formatTime(wavesurfer.getDuration())}`;
            });

            wavesurfer.on('finish', function () {
                document.getElementById('play-pause-audio-btn').textContent = 'Play';
            });
            
             wavesurfer.on('play', function () {
                document.getElementById('play-pause-audio-btn').textContent = 'Pause';
            });

            wavesurfer.on('pause', function () {
                document.getElementById('play-pause-audio-btn').textContent = 'Play';
            });
            
            wavesurfer.on('audioprocess', function() {
                if (wavesurfer.isPlaying()) {
                    waveformTime.textContent = `${formatTime(wavesurfer.getCurrentTime())} / ${formatTime(wavesurfer.getDuration())}`;
                }
            });
            
            wavesurfer.on('seek', function() {
                 waveformTime.textContent = `${formatTime(wavesurfer.getCurrentTime())} / ${formatTime(wavesurfer.getDuration())}`;
            });
        }


        function startAnimationLoop() {
            if (!animationFrameId) {
                requestAnimationFrame((timestamp) => {
                    lastRecordingFrameTime = timestamp;
                    animationLoop(timestamp);
                });
            }
        }

        function stopAnimationLoop() {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            recordingTimer.textContent = `${String(Math.floor(elapsed / 60)).padStart(2, '0')}:${String(elapsed % 60).padStart(2, '0')}`;
        }

        function runCountdown(onComplete) {
            isCountdownActive = true;
            let count = 3;
            countdownSpan.textContent = count;
            countdownOverlay.classList.remove('hidden');
            const intervalId = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownSpan.textContent = count;
                } else {
                    clearInterval(intervalId);
                    countdownOverlay.classList.add('hidden');
                    isCountdownActive = false;
                    if (movieInteraction.active && movieInteraction.primed) {
                        movieInteraction.primed = false;
                    }
                    onComplete();
                }
            }, 1000);
        }

        function toggleCanvasZoom() {
            if (isRecording) {
                toast('Cannot change view while recording.', 2000);
                return;
            }
            isCanvasViewZoomedOut = !isCanvasViewZoomedOut;
            canvasPanel.classList.toggle('is-zoomed-out', isCanvasViewZoomedOut);
            toggleViewBtn.textContent = isCanvasViewZoomedOut ? '⛶' : '⬚';
            toggleViewBtn.title = isCanvasViewZoomedOut ? 'Reset Canvas View (Z)' : 'Zoom Out Canvas (Z)';
        }

        function startMovieRecording() {
            hidePostGenerationActions();
            const currentScene = getCurrentScene();
            if (!currentScene || !currentScene.layers.some(l => !l.committed)) {
                toast('Please add an asset to the scene first.', 2000);
                return;
            }

            if (currentScene.backgroundType === 'video') {
                currentScene.preRecordingMutedState = currentScene.backgroundElement.muted;
                currentScene.backgroundElement.muted = true;
            }

            currentScene.layerStartingStates = {};
            currentScene.layers.forEach(layer => {
                currentScene.layerStartingStates[layer.id] = {
                    x: layer.x,
                    y: layer.y,
                    rot: layer.rot,
                    flipX: layer.flipX
                };
            });

            recordingCanvas.width = masterWidth;
            recordingCanvas.height = masterHeight;

            sceneActionsContainer.classList.add('hidden');
            stopActionsContainer.classList.remove('hidden');
            recordingStatus.classList.remove('hidden');
            updateControlsState();
            
            runCountdown(() => {
                const baselineVisualMs = currentScene._padBaselineMs || 0;
                currentScene._padBaselineMs = baselineVisualMs;

                isRecording = true;
                
                if (movieInteraction.active && movieInteraction.primed) {
                    movieInteraction.primed = false;
                }
                recordingStartTime = Date.now();
                currentScene.layers.forEach(l => {
                    if (l.isProjectileActive) {
                        l.projectileStartX = l.x;
                        l.projectileStartY = l.y;
                        l.projectileTimestamp = recordingStartTime;
                        l.projectileInitialRotation = l.rot;
                        l.projectileInitialFlipX = l.flipX;
                    }
                });
                
                recordingIntervalId = setInterval(updateTimer, 1000);
                
                const canvasStream = recordingCanvas.captureStream(RECORDING_FPS);

                const audioSourceElement = currentScene.audioElement;
                if (audioSourceElement) {
                    audioSourceElement.currentTime = currentScene.audioStartTime || 0;
                    audioSourceElement.loop = true; 
                    
                    let audioStream;
                    if (audioSourceElement.captureStream) audioStream = audioSourceElement.captureStream();
                    else if (audioSourceElement.mozCaptureStream) audioStream = audioSourceElement.mozCaptureStream();

                    if (audioStream && audioStream.getAudioTracks().length > 0) {
                        canvasStream.addTrack(audioStream.getAudioTracks()[0]);
                    }
                }

                const hasAudio = canvasStream.getAudioTracks().length > 0;
                const videoBitsPerSecond = 2500000;
                let mimeType = hasAudio ? 'video/webm; codecs=vp9,opus' : 'video/webm; codecs=vp9';
                let blobFileType = 'video/webm';

                const mp4MimeType = hasAudio ? 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"' : 'video/mp4; codecs="avc1.42E01E"';
                if (MediaRecorder.isTypeSupported(mp4MimeType)) {
                    mimeType = mp4MimeType;
                    blobFileType = 'video/mp4';
                }
                
                layerRecordingBlobType = blobFileType;

                mediaRecorder = new MediaRecorder(canvasStream, {mimeType, videoBitsPerSecond});

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) recordedChunks.push(e.data);
                };
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, {type: blobFileType});
                    layerRecordingUrl = URL.createObjectURL(blob);
                    commitLayerBtn.classList.remove('hidden');
                    commitLayerBtn.classList.add('success');
                    updateControlsState();
                };
                mediaRecorder.start();
                
                if (currentScene && currentScene.backgroundType === 'video') {
                    currentScene.backgroundElement.play();
                }
                if (currentScene.audioElement) {
                    currentScene.audioElement.play();
                }
                toast('Recording started!', 2000);
            });
        }
        function stopMovieRecording() {
            const currentScene = getCurrentScene();
            if (!currentScene) return;
            
            stopActionsContainer.classList.add('hidden');
            recordingTimer.textContent = 'Finalizing...';
            toast('Finalizing recording...', null);

            const elapsedMs = Date.now() - recordingStartTime;
            
            const baseline = currentScene.durationMs || 0;
            
            const targetMs = Math.max(baseline, Math.max(500, elapsedMs));

            const finalizeStop = () => {
                if (currentScene.backgroundType === 'video') {
                    currentScene.backgroundElement.pause();
                    currentScene.backgroundElement.currentTime = 0;
                    if (typeof currentScene.preRecordingMutedState !== 'undefined') {
                        currentScene.backgroundElement.muted = currentScene.preRecordingMutedState;
                    }
                    delete currentScene.preRecordingMutedState;
                }

                if (currentScene.audioElement) {
                    currentScene.audioElement.pause();
                    currentScene.audioElement.currentTime = 0;
                    currentScene.audioElement.loop = false;
                }

                if (mediaRecorder?.state !== 'inactive') {
                    mediaRecorder.stop();
                }

                lastRecordingDurationMs = targetMs;
                ensureSceneDurationMs(currentScene, targetMs);
                isRecording = false;
                
                delete currentScene._padBaselineMs;

                sceneActionsContainer.classList.remove('hidden');
                recordLayerBtn.textContent = 'Re-record Layer';
                recordLayerBtn.classList.remove('record');
                recordingStatus.classList.add('hidden');

                clearInterval(recordingIntervalId);
                recordingTimer.textContent = '00:00';

                toast('Layer recorded successfully! Commit it to add another layer.', 4000);
                updateControlsState();
            };

            if (elapsedMs >= targetMs) {
                finalizeStop();
            } else {
                padRecordingUntil(targetMs, finalizeStop);
            }
        }
        function resetTake() {
            const currentScene = getCurrentScene();
            if (!currentScene) return;

            if (currentScene.layerStartingStates) {
                toast('Ready to re-record. Adjust assets as needed.', 3000);
                currentScene.layers.forEach(layer => {
                    const savedState = currentScene.layerStartingStates[layer.id];
                    if (savedState) {
                        layer.x = savedState.x;
                        layer.y = savedState.y;
                        layer.rot = savedState.rot;
                        layer.flipX = savedState.flipX;
                    }
                });
            }

            resetToReadyState();
            updateControlsState();
        }
        function previewCurrentScene() {
            if (isRecording) return;
            const currentScene = getCurrentScene();
            if (!currentScene) {
                toast('No active scene to preview.', 2000);
                return;
            }

            const intrinsicMs =
                currentScene.backgroundType === 'video'
                    ? getMediaDurationMs(currentScene.backgroundElement, 'video')
                    : currentScene.durationMs || 0;
            ensureSceneDurationMs(currentScene, intrinsicMs);

            const targetMs = Math.max(
                currentScene.durationMs || 0,
                layerRecordingUrl ? lastRecordingDurationMs : 0,
                1000
            );

            let previewUrl = null;
            let videoElementToPlay = null;

            if (layerRecordingUrl) {
                previewUrl = layerRecordingUrl;
            } else if (currentScene.backgroundType === 'video') {
                videoElementToPlay = currentScene.backgroundElement;
            }

            if (previewUrl) {
                previewVideo.src = previewUrl;
                previewVideo.currentTime = 0;
                previewVideo.loop = true;
                previewPopup.classList.add('visible');

                previewVideo.play().then(() => {
                    setTimeout(() => {
                        previewVideo.pause();
                        previewPopup.classList.remove('visible');
                    }, targetMs);
                }).catch(() => {});
            } else if (videoElementToPlay) {
                previewVideo.src = videoElementToPlay.src;
                previewVideo.currentTime = 0;
                previewVideo.loop = true;
                previewPopup.classList.add('visible');

                videoElementToPlay.volume = 1;
                videoElementToPlay.muted = false; 
                videoElementToPlay.play().then(() => {
                    setTimeout(() => {
                        videoElementToPlay.pause();
                        videoElementToPlay.muted = true;
                        videoElementToPlay.currentTime = 0;
                        previewPopup.classList.remove('visible');
                    }, targetMs);
                }).catch(() => {});
            } else {
                previewVideo.removeAttribute('src');
                previewPopup.classList.add('visible');
                setTimeout(() => {
                    previewPopup.classList.remove('visible');
                }, targetMs);
            }
        }

        function getProjectileHandlePosition(layer, dWidth, dHeight) {
            const centerX = movieCanvas.width / 2;
            const centerY = movieCanvas.height / 2;

            let localX, localY;

            if (layer.x >= centerX && layer.y < centerY) { 
                localX = -dWidth / 2 - PROJECTILE_HANDLE_OFFSET;
                localY = dHeight / 2 + PROJECTILE_HANDLE_OFFSET;
            } else if (layer.x < centerX && layer.y < centerY) { 
                localX = dWidth / 2 + PROJECTILE_HANDLE_OFFSET;
                localY = dHeight / 2 + PROJECTILE_HANDLE_OFFSET;
            } else if (layer.x < centerX && layer.y >= centerY) { 
                localX = dWidth / 2 + PROJECTILE_HANDLE_OFFSET;
                localY = -dHeight / 2 - PROJECTILE_HANDLE_OFFSET;
            } else { 
                localX = -dWidth / 2 - PROJECTILE_HANDLE_OFFSET;
                localY = -dHeight / 2 - PROJECTILE_HANDLE_OFFSET;
            }
            
            return { x: localX, y: localY };
        }

        function handleMovieInteractionStart(e) {
            e.preventDefault();
            const point = getMovieCanvasPoint(e);
            const currentScene = getCurrentScene();
            if (!currentScene) return;

            const activeLayer = getActiveLayer();
            let interactionFound = false;

            if (activeLayer) {
                const handle = getMovieHandleAtPoint(point, activeLayer);
                if (handle) {
                    interactionFound = true;
                    if (!isRecording && handle === 'projectile-toggle') {
                        ignoreNextWindowClick = true;
                        activeLayer.isProjectileActive = !activeLayer.isProjectileActive;
                        if (!activeLayer.isProjectileActive) {
                            activeLayer.projectileVectorX = 0;
                            activeLayer.projectileVectorY = 0;
                            activeLayer.gravityValue = 0;
                            activeLayer.projectileRotationRate = 0;
                            gravityMenu.classList.add('hidden');
                        } else {
                            positionGravityMenu(activeLayer);
                        }
                        return;
                    }
                    movieInteraction = {
                        active: true,
                        type: handle === 'rotate' ? 'rotate' : 'resize',
                        layerId: activeLayer.id,
                        handle: handle,
                        startX: point.x,
                        startY: point.y,
                        initialState: JSON.parse(JSON.stringify(activeLayer))
                    };
                } else if (isPointInMovieLayer(point, activeLayer)) {
                    interactionFound = true;
                    if (!isRecording && activeLayer.isProjectileActive) {
                        movieInteraction = {
                            active: true,
                            type: 'projectile-draw',
                            layerId: activeLayer.id
                        };
                        projectileVectorStart = { x: activeLayer.x, y: activeLayer.y };
                        projectileVectorEnd = point;
                        gravityMenu.classList.add('hidden');
                    } else {
                        movieInteraction = {
                            active: true,
                            type: 'drag',
                            layerId: activeLayer.id,
                            offsetX: point.x - activeLayer.x,
                            offsetY: point.y - activeLayer.y,
                        };
                    }
                }
            }

            if (!interactionFound) {
                for (let i = 0; i < currentScene.layers.length; i++) {
                    const l = currentScene.layers[i];
                    if (l.committed) continue;

                    if (isPointInMovieLayer(point, l)) {
                        activeMovieLayerId = l.id;
                        renderLayerPalette();
                        renderStackedLayersPalette();
                        renderTextLayerPalette();
                        updateEditPanelsUI();
                        
                        movieInteraction = {
                            active: true,
                            type: 'drag',
                            layerId: l.id,
                            offsetX: point.x - l.x,
                            offsetY: point.y - l.y,
                        };
                        interactionFound = true;
                        break;
                    }
                }
            }
            
            if (!interactionFound && activeMovieLayerId) {
                activeMovieLayerId = null;
                gravityMenu.classList.add('hidden');
                updateEditPanelsUI();
                renderLayerPalette();
                renderStackedLayersPalette();
                renderTextLayerPalette();
            }
        }
        function getMovieCanvasPoint(e) {
            const rect = canvasPanel.getBoundingClientRect();
            const clientX = e.clientX;
            const clientY = e.clientY;
            const movieCanvasRect = movieCanvas.getBoundingClientRect();
            const scaleX = movieCanvas.width / movieCanvasRect.width;
            const scaleY = movieCanvas.height / movieCanvasRect.height;
            const logicalX = (clientX - movieCanvasRect.left) * scaleX;
            const logicalY = (clientY - movieCanvasRect.top) * scaleY;
            return {x: logicalX, y: logicalY};
        }

        function getMovieHandleAtPoint(point, layer) {
            const l = layer;
            let dWidth, dHeight;

            if (l.type === 'image' || l.type === 'video') {
                const assetWidth = l.type === 'image' ? l.asset.naturalWidth : l.asset.videoWidth;
                const assetHeight = l.type === 'image' ? l.asset.naturalHeight : l.asset.videoHeight;
                if (assetWidth === 0) return null;
                dWidth = l.size;
                dHeight = l.size * (assetHeight / assetWidth);
            } else if (l.type === 'text') {
                const metrics = getTextBlockMetrics(controlsCtx, l.text, l.font, l.fontSize);
                dWidth = metrics.maxWidth;
                dHeight = metrics.totalHeight;
            } else {
                return null;
            }

            const radius = 20;
            const angle = l.rot * Math.PI / 180;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const ROTATION_HANDLE_OFFSET = 30;

            if (!isRecording) {
                const handlePos = getProjectileHandlePosition(l, dWidth, dHeight);
                const projectileHandleLocalX = handlePos.x;
                const projectileHandleLocalY = handlePos.y;
                const projectileHandleWorldX = l.x + (projectileHandleLocalX * cos - projectileHandleLocalY * sin);
                const projectileHandleWorldY = l.y + (projectileHandleLocalX * sin + projectileHandleLocalY * cos);

                if (Math.hypot(point.x - projectileHandleWorldX, point.y - projectileHandleWorldY) < PROJECTILE_HANDLE_SIZE / 2 + 5) {
                    return 'projectile-toggle';
                }
            }

            if (!l.isProjectileActive) {
                const rotHandleY = -dHeight / 2 - ROTATION_HANDLE_OFFSET;
                const rotatedRotHandleX = l.x + (0 * cos - rotHandleY * sin);
                const rotatedRotHandleY = l.y + (0 * sin + rotHandleY * cos);

                if (Math.hypot(point.x - rotatedRotHandleX, point.y - rotatedRotHandleY) < radius) return 'rotate';

                const handles = {
                    tl: {x: -dWidth / 2, y: -dHeight / 2},
                    tr: {x: dWidth / 2, y: -dHeight / 2},
                    bl: {x: -dWidth / 2, y: dHeight / 2},
                    br: {x: dWidth / 2, y: dHeight / 2}
                };
                for (const name in handles) {
                    const h = handles[name];
                    const handleWorldX = l.x + h.x * cos - h.y * sin;
                    const handleWorldY = l.y + h.x * sin + h.y * cos;
                    if (Math.hypot(point.x - handleWorldX, point.y - handleWorldY) < radius) return name;
                }
            }
            return null;
        }

        function isPointInMovieLayer(point, layer) {
            const l = layer;
            let dWidth, dHeight;

            if (l.type === 'image' || l.type === 'video') {
                const assetWidth = l.type === 'image' ? l.asset.naturalWidth : l.asset.videoWidth;
                const assetHeight = l.type === 'image' ? l.asset.naturalHeight : l.asset.videoHeight;
                if (assetWidth === 0) return false;
                dWidth = l.size;
                dHeight = l.size * (assetHeight / assetWidth);
            } else if (l.type === 'text') {
                const metrics = getTextBlockMetrics(controlsCtx, l.text, l.font, l.fontSize);
                dWidth = metrics.maxWidth;
                dHeight = metrics.totalHeight;
            } else {
                return false;
            }

            const dx = point.x - l.x;
            const dy = point.y - l.y;
            const angle = -l.rot * Math.PI / 180;
            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
            return (Math.abs(localX) < dWidth / 2 && Math.abs(localY) < dHeight / 2);
        }

        function positionGravityMenu(layer) {
            const canvasRect = movieCanvas.getBoundingClientRect();
            const panelRect = canvasPanel.getBoundingClientRect();
            let dWidth, dHeight;
            if (layer.type === 'image' || layer.type === 'video') {
                const assetWidth  = layer.type === 'image' ? (layer.asset?.naturalWidth  || 1) : (layer.asset?.videoWidth  || 1);
                const assetHeight = layer.type === 'image' ? (layer.asset?.naturalHeight || 1) : (layer.asset?.videoHeight || 1);
                dWidth  = layer.size;
                dHeight = layer.size * (assetHeight / assetWidth);
            } else if (layer.type === 'text') {
                const metrics = getTextBlockMetrics(controlsCtx, layer.text, layer.font, layer.fontSize);
                dWidth = metrics.maxWidth;
                dHeight = metrics.totalHeight;
            } else {
                return;
            }
            const angle = layer.rot * Math.PI / 180;
            const cos = Math.cos(angle), sin = Math.sin(angle);
            const scaleX = canvasRect.width / movieCanvas.width;
            const scaleY = canvasRect.height / movieCanvas.height;
            const corners = [
                { x: -dWidth/2, y: -dHeight/2 }, { x:  dWidth/2, y: -dHeight/2 },
                { x:  dWidth/2, y:  dHeight/2 }, { x: -dWidth/2, y:  dHeight/2 }
            ];
            const screenCorners = corners.map(c => {
                const rx = c.x * cos - c.y * sin;
                const ry = c.x * sin + c.y * cos;
                return {
                x: (layer.x + rx) * scaleX + panelRect.left,
                y: (layer.y + ry) * scaleY + panelRect.top
                };
            });
            const bbox = {
                minX: Math.min(...screenCorners.map(c => c.x)),
                maxX: Math.max(...screenCorners.map(c => c.x)),
                minY: Math.min(...screenCorners.map(c => c.y)),
                maxY: Math.max(...screenCorners.map(c => c.y))
            };
            const wasHidden = gravityMenu.classList.contains('hidden') || gravityMenu.style.display === 'none';
            if (wasHidden) {
                gravityMenu.classList.remove('hidden');
                gravityMenu.style.visibility = 'hidden';
                gravityMenu.style.display = 'block';
            }
            const menuRect = gravityMenu.getBoundingClientRect();
            const menuWidth = menuRect.width;
            const menuHeight = menuRect.height;
            const margin = 10;
            const assetCX = (bbox.minX + bbox.maxX) / 2;
            const assetCY = (bbox.minY + bbox.maxY) / 2;
            const panelCX = panelRect.left + panelRect.width / 2;
            const panelCY = panelRect.top  + panelRect.height / 2;
            let finalLeft_vp, finalTop_vp;
            if (assetCX >= panelCX && assetCY < panelCY) {
                finalLeft_vp = bbox.minX - menuWidth - margin;
                finalTop_vp  = bbox.maxY + margin;
            } else if (assetCX < panelCX && assetCY < panelCY) {
                finalLeft_vp = bbox.maxX + margin;
                finalTop_vp  = bbox.maxY + margin;
            } else if (assetCX < panelCX && assetCY >= panelCY) {
                finalLeft_vp = bbox.maxX + margin;
                finalTop_vp  = bbox.minY - menuHeight - margin;
            } else {
                finalLeft_vp = bbox.minX - menuWidth - margin;
                finalTop_vp  = bbox.minY - menuHeight - margin;
            }
            const parentEl = gravityMenu.offsetParent || document.body;
            const parentRect = parentEl.getBoundingClientRect();
            let finalLeft = finalLeft_vp - parentRect.left;
            let finalTop  = finalTop_vp  - parentRect.top;
            finalLeft = Math.max(0, Math.min(finalLeft, parentRect.width  - menuWidth));
            finalTop  = Math.max(0, Math.min(finalTop,  parentRect.height - menuHeight));
            gravityMenu.style.left = `${finalLeft}px`;
            gravityMenu.style.top  = `${finalTop}px`;
            gravityMenu.style.visibility = 'visible';
            gravityMenu.style.display = 'block';
            gravityInput.value = Number(layer.gravityValue ?? 0).toFixed(1);
            const rotationRateInput = document.getElementById('gravity-rotation-rate');
            const currentRate = layer.projectileRotationRate || 0;
            rotationRateInput.value = currentRate;
            gravityInstructions.textContent =
                'Click & drag on asset for initial speed. Set gravity & rotation below.';
        }

        function handleMovieInteractionMove(e) {
            if (!movieInteraction.active) {
                updateCursor(e);
                return;
            }
            e.preventDefault();
            const point = getMovieCanvasPoint(e);
            const l = getActiveLayer();
            if (!l) return;

            if (!isRecording && movieInteraction.type === 'projectile-draw') {
                projectileVectorEnd = point;
                l.projectileVectorX = (projectileVectorEnd.x - projectileVectorStart.x) * VELOCITY_MULTIPLIER;
                l.projectileVectorY = (projectileVectorEnd.y - projectileVectorStart.y) * VELOCITY_MULTIPLIER;
                return;
            }

            if (movieInteraction.type === 'drag') {
                l.x = point.x - movieInteraction.offsetX;
                l.y = point.y - movieInteraction.offsetY;
            } else if (movieInteraction.type === 'resize') {
                const iState = movieInteraction.initialState;
                const initialDist = Math.hypot(movieInteraction.startX - iState.x, movieInteraction.startY - iState.y);
                const currentDist = Math.hypot(point.x - iState.x, point.y - iState.y);

                if (initialDist > 1) {
                    const scaleFactor = currentDist / initialDist;
                    if (l.type === 'text') {
                        l.fontSize = Math.max(10, iState.fontSize * scaleFactor);
                        textSizeSlider.value = l.fontSize;
                    } else {
                        l.size = Math.max(20, iState.size * scaleFactor);
                    }
                }
            } else if (movieInteraction.type === 'rotate') {
                const iState = movieInteraction.initialState;
                const initialAngle = Math.atan2(movieInteraction.startY - iState.y, movieInteraction.startX - iState.x) * 180 / Math.PI;
                const currentAngle = Math.atan2(point.y - iState.y, point.x - iState.x) * 180 / Math.PI;
                l.rot = iState.rot + (currentAngle - initialAngle);
            }
        }

        function handleMovieInteractionEnd(e) {
            if (!isRecording && movieInteraction.type === 'projectile-draw') {
                const activeLayer = getActiveLayer();
                if (activeLayer) {
                    toast('Asset motion set!', 2000);
                }
                projectileVectorStart = null;
                projectileVectorEnd = null;
            }
            movieInteraction.active = false
        }

        function updateCursor(e) {
            if (!gravityMenu.classList.contains('hidden') && gravityMenu.style.display !== 'none') {
                movieCanvas.style.cursor = 'default';
                return;
            }

            const point = getMovieCanvasPoint(e);
            const currentScene = getCurrentScene();
            if (!currentScene) {
                movieCanvas.style.cursor = 'default';
                return;
            }
            let newCursor = 'default';
            const activeLayer = getActiveLayer();

            if (activeLayer) {
                if (activeLayer.type === 'text' && activeLayer.committed) {
                    movieCanvas.style.cursor = 'default';
                    return;
                }

                const handle = getMovieHandleAtPoint(point, activeLayer);

                if (isRecording) {
                    if (activeLayer.isProjectileActive) {
                        if (isPointInMovieLayer(point, activeLayer)) {
                            newCursor = 'move';
                        } else {
                            newCursor = 'default';
                        }
                    } else { 
                        if (handle) {
                            newCursor = handle === 'rotate' ? 'grab' : (handle === 'tl' || handle === 'br' ? 'nwse-resize' : 'nesw-resize');
                        } else if (isPointInMovieLayer(point, activeLayer)) {
                            newCursor = 'move';
                        }
                    }
                    movieCanvas.style.cursor = newCursor;
                    return;
                }

                if (handle === 'projectile-toggle') {
                    newCursor = 'pointer';
                    movieCanvas.style.cursor = newCursor;
                    return;
                }

                if (activeLayer.isProjectileActive && isPointInMovieLayer(point, activeLayer)) {
                    newCursor = 'crosshair';
                    movieCanvas.style.cursor = newCursor;
                    return;
                }

                if (!activeLayer.isProjectileActive) {
                    if (handle) {
                        newCursor = handle === 'rotate' ? 'grab' : (handle === 'tl' || handle === 'br' ? 'nwse-resize' : 'nesw-resize')
                    } else if (isPointInMovieLayer(point, activeLayer)) {
                        newCursor = 'move'
                    }
                }
            }

            if (newCursor === 'default') {
                for (let i = currentScene.layers.length - 1; i >= 0; i--) {
                    const l = currentScene.layers[i];
                    if (l.type === 'text' && l.committed) continue;
                    if (isPointInMovieLayer(point, l)) {
                        newCursor = 'pointer'; 
                        break
                    }
                }
            }
            movieCanvas.style.cursor = newCursor
        }

        function continuousResizeLoop() {
            if (!resizeState.isResizing) return;
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                const EXPONENT = 0.78;
                const RESIZE_POWER_FACTOR = 0.01;

                if (activeLayer.type === 'text') {
                    const dynamicSpeed = Math.pow(activeLayer.fontSize, EXPONENT) * RESIZE_POWER_FACTOR;
                    activeLayer.fontSize += dynamicSpeed * resizeState.direction;
                    activeLayer.fontSize = Math.max(10, activeLayer.fontSize);
                } else {
                    const dynamicSpeed = Math.pow(activeLayer.size, EXPONENT) * RESIZE_POWER_FACTOR;
                    activeLayer.size += dynamicSpeed * resizeState.direction;
                    activeLayer.size = Math.max(20, activeLayer.size);
                }
            }
            resizeState.animationFrameId = requestAnimationFrame(continuousResizeLoop);
        }

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            if (document.activeElement === textContentInput || document.activeElement === gravityInput) {
                if (key === 'escape') {
                    document.activeElement.blur();
                    e.preventDefault()
                }
                return;
            }
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT' || document.activeElement.tagName === 'TEXTAREA') return;

            const activeLayer = getActiveLayer();

            if (key === 'z') {
                e.preventDefault();
                toggleCanvasZoom();
                return;
            }

            if (key === 'r') {
                e.preventDefault();
                if (isRecording) {
                    stopMovieRecording()
                } else if (!recordLayerBtn.disabled) {
                    startMovieRecording()
                }
                return;
            }

            if (key === 'g') {
                e.preventDefault();
                if (activeLayer) {
                    const isGravityMenuVisible = !gravityMenu.classList.contains('hidden') && gravityMenu.style.display !== 'none';
                    if (isGravityMenuVisible) {
                        gravityMenu.classList.add('hidden');
                    } else {
                        if (!activeLayer.isProjectileActive) {
                            activeLayer.isProjectileActive = true;
                            activeLayer.projectileVectorX = 0;
                            activeLayer.projectileVectorY = 0;
                            activeLayer.gravityValue = 0;
                            toast('Projectile motion enabled via G key.', 2000);
                        }
                        ignoreNextWindowClick = true;
                        positionGravityMenu(activeLayer);
                    }
                } else {
                    toast('Select an asset first to open the Gravity menu.', 2000);
                }
                return;
            }
            
            if (!activeLayer) return;
            
            if (!activeLayer.committed && activeLayer.type !== 'text' && (key === 'q' || key === 'w')) {
                e.preventDefault();
                const scene = getCurrentScene();
                if (!scene) return;

                const activeVisualLayers = scene.layers.filter(l => l.type !== 'text' && !l.committed);
                const otherLayers = scene.layers.filter(l => l.type === 'text' || l.committed);

                const currentIndex = activeVisualLayers.findIndex(l => l.id === activeLayer.id);
                if (currentIndex === -1) return; 

                let newIndex;
                if (key === 'q') { 
                    newIndex = currentIndex - 1;
                } else { 
                    newIndex = currentIndex + 1;
                }

                if (newIndex >= 0 && newIndex < activeVisualLayers.length) {
                    const temp = activeVisualLayers[currentIndex];
                    activeVisualLayers[currentIndex] = activeVisualLayers[newIndex];
                    activeVisualLayers[newIndex] = temp;
                    scene.layers = [...activeVisualLayers, ...otherLayers];
                    renderLayerPalette();
                    renderStackedLayersPalette();
                }
                return;
            }


            if (key === 's') {
                e.preventDefault();
                activeLayer.flipX = !activeLayer.flipX;
            } else if (key === 'd' || key === 'f') {
                e.preventDefault();
                if (resizeState.isResizing) return;
                resizeState.isResizing = true;
                resizeState.direction = (key === 'd') ? 1 : -1;
                continuousResizeLoop();
            } else if (key === 'delete' || key === 'backspace') {
                e.preventDefault();
                deleteMovieLayer(activeLayer.id);
                toast('Layer deleted', 2000);
            }
        }

        function handleKeyUp(e) {
            const key = e.key.toLowerCase();
            if (key === 'd' || key === 'f') {
                e.preventDefault();
                resizeState.isResizing = false;
                cancelAnimationFrame(resizeState.animationFrameId)
            }
        }

        function clearProject() {
            hidePostGenerationActions();
            scenes.forEach(scene => {
                if (scene.audioElement) {
                    URL.revokeObjectURL(scene.audioElement.src)
                }
                scene.committedLayerSrcs.forEach(src => {
                    if (src.startsWith('blob:')) URL.revokeObjectURL(src)
                })
            });
            scenes = [];
            activeSceneId = null;
            activeMovieLayerId = null;
            lastRecordingDurationMs = 0;
            movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
            controlsCtx.clearRect(0, 0, controlsOverlayCanvas.width, controlsOverlayCanvas.height);
            canvasPlaceholder.classList.remove('hidden');
            updateControlsState();
            updateEditPanelsUI();
            updateAudioUI();
            gravityMenu.classList.add('hidden');
            updateCanvasPanelBackground(null);
            toast("Project cleared.", 2000);
        }

        let confirmCallback = null;

        function openConfirmationModal(text, onConfirm) {
            confirmationText.textContent = text;
            confirmCallback = onConfirm;
            confirmationOverlay.classList.add('visible')
        }

        function closeConfirmationModal() {
            confirmationOverlay.classList.remove('visible');
            confirmCallback = null
        }
        
        async function processAssetFile(file) {
            if (!file) return;

            const currentScene = getCurrentScene();
            if (!currentScene) {
                toast('Please add a background to the scene first.', 3000);
                initialBackgroundInput.click();
                return;
            }

            const isImage = file.type.startsWith('image/');
            const isVideo = file.type.startsWith('video/');

            if (!isImage && !isVideo) {
                toast('Unsupported file. Use PNG, MP4, or MOV.', 3000);
                return;
            }
            
            toast('Processing asset...', 1000);
            try {
                const hash = await calculateFileHash(file);
                let existingAsset = await getAssetByHash(hash);
                let assetFile = file;

                if (existingAsset) {
                    toast('Asset already in library.', 2000);
                    assetFile = existingAsset.file; 
                } else {
                    const newId = await saveAssetToDB(file, hash, 'asset');
                    const newLibraryAsset = {
                        id: newId,
                        file: file,
                        hash: hash,
                        name: file.name,
                        type: 'asset',
                        src: URL.createObjectURL(file)
                    };
                    projectLibrary.unshift(newLibraryAsset);
                    updateProjectLibraryDisplay();
                    toast('Asset saved to local library.', 2000);
                }

                const blobUrl = URL.createObjectURL(assetFile);
                const assetType = assetFile.type.startsWith('video/') ? 'video' : 'image';
                addMovieLayer(blobUrl, { type: assetType });

            } catch (error) {
                console.error("Error processing asset file:", error);
                toast('Could not process or save asset.', 4000);
            } finally {
                closeAssetLibrary();
            }
        }


        const setupEventListeners = () => {
            const setValNull = e => e.target.value = null;
            
            toggleViewBtn.addEventListener('click', toggleCanvasZoom);

            versionLink.addEventListener('click', (e) => {
                e.preventDefault();
                versionPopupOverlay.style.display = 'flex';
            });
            closeVersionPopupBtn.addEventListener('click', () => {
                versionPopupOverlay.style.display = 'none';
            });
            versionPopupOverlay.addEventListener('click', (e) => {
                if (e.target === versionPopupOverlay) {
                    versionPopupOverlay.style.display = 'none';
                }
            });

            initialBackgroundInput.addEventListener('change', e => {
                handleBackgroundUpload(e.target.files[0], 'initial');
                setValNull(e)
            });
            addSceneBtn.addEventListener('click', () => {
                if (scenes.length === 0) {
                    initialBackgroundInput.click()
                } else {
                    newSceneBackgroundInput.click()
                }
            });
            newSceneBackgroundInput.addEventListener('change', e => {
                handleBackgroundUpload(e.target.files[0], 'add');
                setValNull(e)
            });
            
            const assetDropZone = document.getElementById('mg-asset-drop-zone');
            
            document.getElementById('mg-asset-library-close').addEventListener('click', closeAssetLibrary);
            assetLibraryOverlay.addEventListener('click', e => {
                if (e.target === assetLibraryOverlay) closeAssetLibrary();
            });

            assetDropZone.addEventListener('click', () => {
                assetPickerFileInput.click();
            });

            assetPickerFileInput.addEventListener('change', e => {
                processAssetFile(e.target.files?.[0]);
                setValNull(e);
            });

            assetDropZone.addEventListener('dragover', e => {
                e.preventDefault();
                assetDropZone.classList.add('drag-over');
            });

            assetDropZone.addEventListener('dragleave', e => {
                e.preventDefault();
                assetDropZone.classList.remove('drag-over');
            });

            assetDropZone.addEventListener('drop', e => {
                e.preventDefault();
                assetDropZone.classList.remove('drag-over');
                const file = e.dataTransfer.files?.[0];
                if (file) {
                    processAssetFile(file);
                }
            });

            textBtn.addEventListener('click', e => {
                e.stopPropagation();
                loadGoogleFonts();
                textDropdown.classList.toggle('visible');
                shortcutsDropdown.classList.remove('visible');
                visualsDropdown.classList.remove('visible');
                audioDropdown.classList.remove('visible');
            });
            
            addNewTextLayerBtn.addEventListener('click', e => {
                e.stopPropagation();
                if (isRecording) {
                    toast('Cannot add text while recording.', 2000);
                    return;
                }
                addTextLayer();
            });

            recordLayerBtn.addEventListener('click', () => {
                if (recordLayerBtn.textContent === 'Re-record Layer') {
                    resetTake();
                } 
                else {
                    startMovieRecording();
                }
            });
            stopLayerBtn.addEventListener('click', stopMovieRecording);
            previewSceneBtn.addEventListener('click', previewCurrentScene);
            
            commitLayerBtn.addEventListener('click', () => {
                hidePostGenerationActions();
                const currentScene = getCurrentScene();
                if (!currentScene || !layerRecordingUrl) return;

                currentScene.layerStartingStates = null;
                ensureSceneDurationMs(currentScene, Math.max(500, lastRecordingDurationMs));
                
                const visualLayersToCommit = currentScene.layers.filter(l => l.type === 'image' || l.type === 'video');
                const sourcesToCommit = visualLayersToCommit.map(l => l.src);
                
                if (sourcesToCommit.length > 0) {
                    currentScene.committedLayerSrcs.push(sourcesToCommit);
                }

                currentScene.layers.forEach(layer => {
                    if (layer.type === 'text') {
                        layer.committed = true;
                    }
                });

                currentScene.layers = currentScene.layers.filter(l => l.type === 'text');

                fetch(layerRecordingUrl).then(res => res.blob()).then(blob => {
                    handleBackgroundUpload(blob, '', true);
                    lastRecordingDurationMs = 0;
                    const scene = getCurrentScene();
                    if (scene && scene.backgroundType === 'video') {
                        const bg = scene.backgroundElement;
                        const finalizeDur = () => {
                            ensureSceneDurationMs(scene, getMediaDurationMs(bg, 'video'))
                        };
                        if (bg.readyState >= 1) finalizeDur();
                        else bg.addEventListener('loadedmetadata', finalizeDur, {once: true})
                    }
                }).catch(error => {
                    console.error('Error fetching recorded blob for commit:', error);
                    toast('Failed to commit layer.', 4000);
                    resetToReadyState()
                })
            });

            generateProjectBtn.addEventListener('click', () => {
                if (scenes.length === 0) {
                    toast('Please create a scene to generate a project.', 3000);
                    return;
                }
                if (isRecording) {
                    toast('Please stop recording before generating.', 3000);
                    return;
                }

                generationOverlay.classList.add('visible');

                hidePostGenerationActions();

                let potentialPreviewUrl = null;
                const currentScene = getCurrentScene();

                if (layerRecordingUrl) {
                    potentialPreviewUrl = layerRecordingUrl;
                } else if (currentScene && currentScene.backgroundElement.src.startsWith('blob:')) {
                    potentialPreviewUrl = currentScene.backgroundElement.src;
                } else {
                    toast('Record a layer first to generate a video.', 4000);
                    generationOverlay.classList.remove('visible');
                    return;
                }
                
                setTimeout(() => {
                    if (potentialPreviewUrl) {
                        fetch(potentialPreviewUrl)
                            .then(res => res.blob())
                            .then(blob => {
                                const generatedUrl = URL.createObjectURL(blob);
                                
                                const downloadBtn = document.getElementById('mg-movie-download');
                                const previewBtn = document.getElementById('mg-preview-btn');
                                const postGenActions = document.getElementById('post-generation-actions');
                                
                                downloadBtn.dataset.downloadUrl = generatedUrl;
                                previewBtn.dataset.previewUrl = generatedUrl;
                                downloadBtn.dataset.filetype = layerRecordingBlobType;

                                postGenActions.classList.remove('hidden');
                                previewBtn.classList.remove('hidden');
                                downloadBtn.classList.remove('hidden');

                                toast('Project generation complete! You can continue editing.', 4000);
                            }).catch(err => {
                                toast('Could not create file for generation.', 3000);
                            });
                    }
                    generationOverlay.classList.remove('visible');
                }, 1500);
            });

            movieDownloadBtn.addEventListener('click', () => {
                const url = movieDownloadBtn.dataset.downloadUrl;
                if (url) {
                    const link = document.createElement('a');
                    link.href = url;
                    const fileExtension = movieDownloadBtn.dataset.filetype === 'video/mp4' ? '.mp4' : '.webm';
                    link.download = `movie-maker-masterpiece${fileExtension}`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } else {
                    toast('No file available to download.', 2000);
                }
            });

            previewBtn.addEventListener('click', () => {
                const url = previewBtn.dataset.previewUrl;
                if (url) {
                    previewVideo.src = url;
                    previewVideo.currentTime = 0;
                    previewVideo.loop = true;
                    previewPopup.classList.add('visible');
                    previewVideo.play().catch(() => {});
                }
            });

            document.getElementById('mg-preview-close-btn').addEventListener('click', () => {
                previewVideo.pause();
                previewPopup.classList.remove('visible')
            });

            deleteSceneBtn.addEventListener('click', () => {
                const text = "This will permanently delete the current scene. Are you sure?";
                openConfirmationModal(text, () => {
                    deleteScene(activeSceneId);
                    closeConfirmationModal()
                })
            });
            confirmYesBtn.addEventListener('click', () => {
                if (confirmCallback) confirmCallback()
            });
            confirmNoBtn.addEventListener('click', closeConfirmationModal);
            confirmationOverlay.addEventListener('click', e => e.stopPropagation());
            document.getElementById('mg-confirmation-dialog').addEventListener('click', e => e.stopPropagation());

            canvasPanel.addEventListener('mousedown', handleMovieInteractionStart);
            window.addEventListener('mousemove', handleMovieInteractionMove);
            window.addEventListener('mouseup', handleMovieInteractionEnd);
            canvasPanel.addEventListener('mouseleave', () => {
                if (!movieInteraction.active) {
                    movieCanvas.style.cursor = 'default'
                }
            });

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);

            canvasPlaceholder.addEventListener('click', () => initialBackgroundInput.click());
            canvasPanel.addEventListener('dragover', e => {
                e.preventDefault();
                if (scenes.length === 0) canvasPanel.classList.add('drag-over')
            });
            canvasPanel.addEventListener('dragleave', e => {
                e.preventDefault();
                canvasPanel.classList.remove('drag-over')
            });
            canvasPanel.addEventListener('drop', e => {
                e.preventDefault();
                canvasPanel.classList.remove('drag-over');
                if (scenes.length === 0) {
                    const file = e.dataTransfer.files[0];
                    if (file) handleBackgroundUpload(file, 'initial')
                }
            });

            shortcutsBtn.addEventListener('click', e => {
                e.stopPropagation();
                shortcutsDropdown.classList.toggle('visible');
                visualsDropdown.classList.remove('visible');
                textDropdown.classList.remove('visible');
                audioDropdown.classList.remove('visible');
            });
            visualsBtn.addEventListener('click', e => {
                e.stopPropagation();
                visualsDropdown.classList.toggle('visible');
                shortcutsDropdown.classList.remove('visible');
                textDropdown.classList.remove('visible');
                audioDropdown.classList.remove('visible');
            });
            audioBtn.addEventListener('click', e => {
                e.stopPropagation();
                loadWaveSurfer();
                audioDropdown.classList.toggle('visible');
                shortcutsDropdown.classList.remove('visible');
                visualsDropdown.classList.remove('visible');
                textDropdown.classList.remove('visible');
            });

            visualsDropdown.addEventListener('click', e => e.stopPropagation());
            textDropdown.addEventListener('click', e => e.stopPropagation());
            audioDropdown.addEventListener('click', e => e.stopPropagation());
            shortcutsDropdown.addEventListener('click', e => e.stopPropagation());

            applyGravityBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const activeLayer = getActiveLayer();
                if (activeLayer) {
                    activeLayer.gravityValue = parseFloat(gravityInput.value);
                    if (isNaN(activeLayer.gravityValue)) {
                        activeLayer.gravityValue = 0;
                        gravityInput.value = 0;
                    }

                    const rotationRateInput = document.getElementById('gravity-rotation-rate');
                    let rate = parseFloat(rotationRateInput.value);
                    if (isNaN(rate)) {
                        rate = 0;
                    }
                    activeLayer.projectileRotationRate = rate;

                    toast(`Motion updated: Gravity ${activeLayer.gravityValue.toFixed(1)}, Rotation ${activeLayer.projectileRotationRate} deg/s`, 2500);
                    gravityMenu.classList.add('hidden');
                }
            });
            cancelGravityBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                gravityMenu.classList.add('hidden');
            });
            gravityMenu.addEventListener('click', e => e.stopPropagation());

            sceneAudioInput.addEventListener('change', e => {
                const file = e.target.files[0];
                const currentScene = getCurrentScene();
                if (!file || !currentScene) return;
                if (currentScene.audioElement) {
                    URL.revokeObjectURL(currentScene.audioElement.src)
                }
                const audioURL = URL.createObjectURL(file);
                currentScene.audioElement = new Audio(audioURL);
                currentScene.audioName = file.name;
                currentScene.audioStartTime = 0;
                currentScene.audioElement.addEventListener('loadedmetadata', () => {
                    const aDur = Math.floor((currentScene.audioElement.duration || 0) * 1000);
                    currentScene.audioDurationMs = aDur
                });

                initWaveform(audioURL);

                toast('Audio added! Select a start time and preview.', 4000);
                updateAudioUI();
                setValNull(e)
            });

            removeAudioBtn.addEventListener('click', () => {
                const currentScene = getCurrentScene();
                if (currentScene && currentScene.audioElement) {
                    URL.revokeObjectURL(currentScene.audioElement.src);
                    currentScene.audioElement = null;
                    currentScene.audioName = null;
                    currentScene.audioDurationMs = 0;
                    currentScene.audioStartTime = 0;

                    if (wavesurfer) {
                        wavesurfer.destroy();
                        wavesurfer = null;
                    }
                    document.getElementById('waveform').style.display = 'none';
                    document.getElementById('audio-playback-controls').style.display = 'none';
                    document.getElementById('audio-instructions').style.display = 'none';
                    document.getElementById('waveform-time').style.display = 'none';
                    
                    toast('Audio removed from scene.', 2000);
                    updateAudioUI();
                }
            });

            document.getElementById('play-pause-audio-btn').addEventListener('click', () => {
                if (wavesurfer) {
                    wavesurfer.playPause();
                }
            });

            document.getElementById('set-start-time-btn').addEventListener('click', () => {
                if (wavesurfer) {
                    if (wavesurfer.isPlaying()) {
                        wavesurfer.pause();
                    }

                    const currentScene = getCurrentScene();
                    if (currentScene) {
                        currentScene.audioStartTime = wavesurfer.getCurrentTime(); 
                        toast(`Start time set to ${currentScene.audioStartTime.toFixed(2)} seconds.`, 3000);
                    }
                    
                    audioDropdown.classList.remove('visible');
                }
            });


            assetOpacitySlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && (activeLayer.type === 'image' || activeLayer.type === 'video')) activeLayer.opacity = parseFloat(e.target.value)
            });
            assetBrightnessSlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && (activeLayer.type === 'image' || activeLayer.type === 'video')) activeLayer.brightness = parseFloat(e.target.value)
            });
            assetSaturationSlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && (activeLayer.type === 'image' || activeLayer.type === 'video')) activeLayer.saturation = parseFloat(e.target.value)
            });

            shadowEnable.addEventListener('change', () => {
                const l = getActiveLayer();
                if (l) {
                    l.shadow.enabled = shadowEnable.checked;
                    shadowControls.classList.toggle('disabled', !shadowEnable.checked);
                }
            });
            shadowColor.addEventListener('input', () => {
                const l = getActiveLayer();
                if (l) l.shadow.color = shadowColor.value;
            });
            shadowBlur.addEventListener('input', () => {
                const l = getActiveLayer();
                if (l) l.shadow.blur = shadowBlur.value;
            });
            shadowOffsetX.addEventListener('input', () => {
                const l = getActiveLayer();
                if (l) l.shadow.offsetX = shadowOffsetX.value;
            });
            shadowOffsetY.addEventListener('input', () => {
                const l = getActiveLayer();
                if (l) l.shadow.offsetY = shadowOffsetY.value;
            });
            borderEnable.addEventListener('change', () => {
                const l = getActiveLayer();
                if (l) {
                    l.border.enabled = borderEnable.checked;
                    borderControls.classList.toggle('disabled', !borderEnable.checked);
                }
            });
            borderColor.addEventListener('input', () => {
                const l = getActiveLayer();
                if (l) l.border.color = borderColor.value;
            });
            borderWidth.addEventListener('input', () => {
                const l = getActiveLayer();
                if (l) l.border.width = borderWidth.value;
            });

            const assetTabBtn = document.getElementById('asset-tab-btn');
            const backgroundTabBtn = document.getElementById('background-tab-btn');
            const assetTabContent = document.getElementById('asset-tab-content');
            const backgroundTabContent = document.getElementById('background-tab-content');

            assetTabBtn.addEventListener('click', () => {
                assetTabBtn.classList.add('active');
                backgroundTabBtn.classList.remove('active');
                assetTabContent.classList.remove('hidden');
                backgroundTabContent.classList.add('hidden');
            });

            backgroundTabBtn.addEventListener('click', () => {
                backgroundTabBtn.classList.add('active');
                assetTabBtn.classList.remove('active');
                backgroundTabContent.classList.remove('hidden');
                assetTabContent.classList.add('hidden');
            });


            textContentInput.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.text = e.target.value;
                    renderTextLayerPalette();
                }
            });
            
            const customFontSelectTrigger = document.getElementById('custom-font-select-trigger');
            const customFontOptions = document.getElementById('custom-font-options');
            const customFontLabel = document.getElementById('custom-font-select-label');

            Array.from(textFontSelect.options).forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.classList.add('custom-font-option');
                optionDiv.textContent = option.textContent;
                optionDiv.dataset.value = option.value;
                optionDiv.style.fontFamily = option.value;
                customFontOptions.appendChild(optionDiv);

                optionDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const activeLayer = getActiveLayer();
                    if (activeLayer && activeLayer.type === 'text') {
                        activeLayer.font = option.value;
                        textFontSelect.value = option.value; 
                        customFontLabel.textContent = option.textContent;
                        originalFontBeforeHover = null; 
                        renderTextLayerPalette();
                    }
                    customFontOptions.style.display = 'none';
                });

                optionDiv.addEventListener('mouseenter', () => {
                    const activeLayer = getActiveLayer();
                    if (activeLayer && activeLayer.type === 'text') {
                        if (originalFontBeforeHover === null) {
                           originalFontBeforeHover = activeLayer.font;
                        }
                        activeLayer.font = option.value;
                    }
                });
            });

            customFontOptions.addEventListener('mouseleave', () => {
                 const activeLayer = getActiveLayer();
                 if (activeLayer && activeLayer.type === 'text' && originalFontBeforeHover !== null) {
                    activeLayer.font = originalFontBeforeHover;
                    originalFontBeforeHover = null;
                 }
            });

            customFontSelectTrigger.addEventListener('click', (e) => {
                e.stopPropagation();
                const isVisible = customFontOptions.style.display === 'block';
                customFontOptions.style.display = isVisible ? 'none' : 'block';
            });

            textSizeSlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.fontSize = parseFloat(e.target.value);
                }
            });
            textColorInput.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.color = e.target.value;
                }
            });
            textStrokeColorInput.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.strokeColor = e.target.value;
                }
            });
            textStrokeWidthSlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.strokeWidth = parseInt(e.target.value, 10);
                }
            });
            textOpacitySlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.opacity = parseFloat(e.target.value);
                }
            });
            textBrightnessSlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.brightness = parseFloat(e.target.value);
                }
            });

            bgBrightnessSlider.addEventListener('input', e => {
                const scene = getCurrentScene();
                if (scene) scene.bgBrightness = parseFloat(e.target.value);
            });
            bgSaturationSlider.addEventListener('input', e => {
                const scene = getCurrentScene();
                if (scene) scene.bgSaturation = parseFloat(e.target.value);
            });

            const allSliders = document.querySelectorAll('input[type="range"]');
            allSliders.forEach(slider => {
                slider.addEventListener('mousedown', () => isDraggingSlider = true);
            });

            const allScrubbingSliders = document.querySelectorAll('#visuals-dropdown input[type="range"], #text-dropdown input[type="range"]');

            const handleSliderScrubStart = (e) => {
                const sliderContainer = e.target.closest('.slider-container');
                const dropdown = e.target.closest('#visuals-dropdown, #text-dropdown');
                if (sliderContainer && dropdown) {
                    dropdown.classList.add('is-scrubbing');
                    sliderContainer.classList.add('is-active-slider');
                }
            }

            const handleSliderScrubEnd = () => {
                const scrubbingDropdown = document.querySelector('#visuals-dropdown.is-scrubbing, #text-dropdown.is-scrubbing');
                if (scrubbingDropdown) {
                    scrubbingDropdown.classList.remove('is-scrubbing');
                }
                const activeSlider = document.querySelector('.is-active-slider');
                if (activeSlider) {
                    activeSlider.classList.remove('is-active-slider');
                }
            }

            allScrubbingSliders.forEach(slider => {
                slider.addEventListener('mousedown', handleSliderScrubStart);
            });

            const endDrag = () => {
                setTimeout(() => {
                    isDraggingSlider = false;
                }, 50);
                handleSliderScrubEnd();
            };

            window.addEventListener('mouseup', endDrag);

            window.addEventListener('click', (e) => {
                if (ignoreNextWindowClick) {
                    ignoreNextWindowClick = false;
                    return;
                }

                shortcutsDropdown.classList.remove('visible');
                visualsDropdown.classList.remove('visible');
                textDropdown.classList.remove('visible');
                audioDropdown.classList.remove('visible');
                customFontOptions.style.display = 'none';
                
                if (gravityMenu.style.display === 'block') {
                     gravityMenu.classList.add('hidden');
                }
            });

            window.addEventListener('paste', e => {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable)) {
                    return;
                }

                const files = e.clipboardData?.files;
                if (!files || files.length === 0) return;

                let fileToUpload = null;
                for (const file of files) {
                    if (file.type.startsWith('image/') || file.type.startsWith('video/')) {
                        fileToUpload = file;
                        break;
                    }
                }

                if (fileToUpload) {
                    e.preventDefault();
                    if (assetLibraryOverlay.classList.contains('visible')) {
                        toast('Pasted file added as asset.', 2500);
                        processAssetFile(fileToUpload);
                    } else if (scenes.length === 0) {
                        toast('Pasted file added as first scene.', 2500);
                        handleBackgroundUpload(fileToUpload, 'initial');
                    }
                }
            });
            
            projectLibrarySeeMoreBtn.addEventListener('click', () => {
                populateProjectLibraryPopup();
                projectLibraryPopupOverlay.classList.add('visible');
            });

            projectLibraryPopupCloseBtn.addEventListener('click', () => {
                projectLibraryPopupOverlay.classList.remove('visible');
            });

            projectLibraryPopupOverlay.addEventListener('click', e => {
                if (e.target === projectLibraryPopupOverlay) {
                    projectLibraryPopupOverlay.classList.remove('visible');
                }
            });
            
            libraryTabAssets.addEventListener('click', () => {
                libraryTabAssets.classList.add('active');
                libraryTabBackgrounds.classList.remove('active');
                projectLibraryGridAssets.classList.remove('hidden');
                projectLibraryGridBackgrounds.classList.add('hidden');
            });

            libraryTabBackgrounds.addEventListener('click', () => {
                libraryTabBackgrounds.classList.add('active');
                libraryTabAssets.classList.remove('active');
                projectLibraryGridBackgrounds.classList.remove('hidden');
                projectLibraryGridAssets.classList.add('hidden');
            });


            const canvasResizeObserver = new ResizeObserver(resizeCanvas);
            canvasResizeObserver.observe(canvasPanel);
        };
        
        async function initializeApp() {
            renderLayerPalette();
            renderStackedLayersPalette();
            updateEditPanelsUI();
            updateAudioUI();
            setupEventListeners();

            const savedTheme = localStorage.getItem('selectedTheme');
            const initialTheme = savedTheme || 'classic light';
            applyTheme(initialTheme);
            currentThemeNameSpan.textContent = initialTheme;
            populateThemeList();

            try {
                const records = await getAllAssetsFromDB();
                records.sort((a, b) => b.createdAt - a.createdAt);
                
                projectLibrary = [];
                projectLibraryBackgrounds = [];

                records.forEach(record => {
                    const libraryItem = {
                        id: record.id,
                        file: record.file,
                        hash: record.hash,
                        name: record.name,
                        type: record.type || 'asset',
                        src: URL.createObjectURL(record.file)
                    };

                    if (libraryItem.type === 'background') {
                        projectLibraryBackgrounds.push(libraryItem);
                    } else {
                        projectLibrary.push(libraryItem);
                    }
                });
                
                updateProjectLibraryDisplay();

            } catch (error) {
                console.error("Could not initialize project library from DB:", error);
                projectLibraryPlaceholder.textContent = "Error loading assets.";
            }

            startAnimationLoop();
            
            // PWA Service Worker Registration
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('/sw.js').then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    }, err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
                });
            }
        }

        initializeApp();
    })();
    
    document.addEventListener('click', function(event) {
        
        const dropdowns = [
            { menuId: 'visuals-dropdown', buttonId: 'visuals-btn' },
            { menuId: 'text-dropdown', buttonId: 'text-btn' },
            { menuId: 'audio-dropdown', buttonId: 'audio-btn' },
            { menuId: 'shortcuts-dropdown', buttonId: 'shortcuts-btn' }
        ];

        dropdowns.forEach(pair => {
            const menu = document.getElementById(pair.menuId);
            const button = document.getElementById(pair.buttonId);

            if (!menu || !button) {
                return;
            }
            
            const isClickInside = menu.contains(event.target) || button.contains(event.target);
            
            if (!isClickInside && menu.classList.contains('visible')) {
                menu.classList.remove('visible');
            }
        });
    });
</script>
